<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>this is panke&#39;s blog</title>
    <description>welcome</description>
    <link>http://panke.me//</link>
    <atom:link href="http://panke.me//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 11 Aug 2016 23:17:56 +0800</pubDate>
    <lastBuildDate>Thu, 11 Aug 2016 23:17:56 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>this is a test</title>
        <description>&lt;h3 id=&quot;this-is-test&quot;&gt;this is test&lt;/h3&gt;

&lt;p&gt;hello world&lt;/p&gt;

&lt;p&gt;http://www.tuicool.com/articles/YfMveu&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://panke.me//test/this_is_test</link>
        <guid isPermaLink="true">http://panke.me//test/this_is_test</guid>
        
        
        <category>test</category>
        
      </item>
    
      <item>
        <title>手动安装 WAMP 环境</title>
        <description>&lt;p&gt;&lt;em&gt;原回答在 2014/04/30 由 &lt;code&gt;user256743&lt;/code&gt; 发表于 &lt;a href=&quot;http://superuser.com/questions/748117/how-to-manually-install-apache-php-and-mysql-on-windows&quot;&gt;http://superuser.com/questions/748117/how-to-manually-install-apache-php-and-mysql-on-windows&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;#环境&lt;/p&gt;

&lt;p&gt;我的系统是 Win7 32 位&lt;/p&gt;

&lt;p&gt;如果你的系统是 64 的, 建议尽量下载并使用 64 位的各软件&lt;/p&gt;

&lt;p&gt;你当然可以下载自己想要的版本的各软件, 也可以把各软件装到自己想要的目录中
但是为了避免不必要的麻烦, 建议完全跟着教程来&lt;/p&gt;

&lt;p&gt;#参考&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;http://httpd.apache.org/docs/current/platform/windows.html&lt;/li&gt;
  &lt;li&gt;http://www.php.net/manual/en/install.windows.apache2.php&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#准备&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载   &lt;a href=&quot;http://www.apachelounge.com/download/VC11/binaries/httpd-2.4.20-win32-VC11.zip&quot; title=&quot;httpd-2.4.20-win32-VC11.zip &quot;&gt;Apache&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;下载   &lt;a href=&quot;http://windows.php.net/downloads/releases/php-5.6.20-Win32-VC11-x86.zip&quot; title=&quot;php-5.6.20-Win32-VC11-x86.zip&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;下载   &lt;a href=&quot;https://dev.mysql.com/get/Downloads/MySQLInstaller/mysql-installer-web-community-5.6.27.0.msi&quot; title=&quot;mysql-installer-web-community-5.6.27.0.msi&quot;&gt;MySQL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;下载   &lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=30679&quot; title=&quot;vs download site&quot;&gt;VS2012&lt;/a&gt;[可选]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#安装&lt;/p&gt;

&lt;p&gt;###安装 Apache&lt;/p&gt;

&lt;p&gt;解压 Apache 到 C 盘根目录, 解压完后目录应该像这样: &lt;code&gt;C:\Apache24\bin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开 cmd, 运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd C:\Apache24\bin
httpd.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不报错, 则说明安装正常&lt;/p&gt;

&lt;p&gt;如果报找不到 &lt;code&gt;MSVCR110.dll&lt;/code&gt;, 则需要安装 &lt;code&gt;VS2012&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果报无法绑定 80 端口, 检查是否有其他程序占用 80 端口, 关闭之&lt;/p&gt;

&lt;p&gt;如果报 &lt;code&gt;Could not reliably determine the ...&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;打开 &lt;code&gt;C:\Apache2\conf\httpd.conf&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;找到 &lt;code&gt;ServerName&lt;/code&gt; 这一行, 替换为:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  ServerName localhost
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;确保防火墙没有屏蔽 Apache&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;http://localhost&lt;/code&gt;, 如果你看到 &lt;code&gt;It Works&lt;/code&gt; 字样, 说明运行成功&lt;/p&gt;

&lt;p&gt;如果你想要开机自动启动 Apache, 运行 &lt;code&gt;httpd.exe -k install&lt;/code&gt;. 然后可以在 windows 服务中控制 Apache2.4, 让其自动启动&lt;/p&gt;

&lt;p&gt;###安装 PHP&lt;/p&gt;

&lt;p&gt;在 C 盘根目录新建文件夹 &lt;code&gt;PHP/&lt;/code&gt;, 解压 PHP  压缩包 到此文件夹中, 路径看上去是这样: &lt;code&gt;C:\PHP\ext&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;C:\PHP&lt;/code&gt; 目录中, 重命名 &lt;code&gt;php.ini-production&lt;/code&gt; 或者 &lt;code&gt;php.ini-development&lt;/code&gt; 为 &lt;code&gt;php.ini&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;php.ini&lt;/code&gt;, 找到 &lt;code&gt;extension_dir = &quot;ext&quot;&lt;/code&gt; 这一行并取消注释(去掉行前的 ;)&lt;/p&gt;

&lt;p&gt;###配置 Apache 使用 PHP&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;C:\Apache24\conf\httpd.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在所有的 &lt;code&gt;LoadModule&lt;/code&gt; 那些行的下面, 添加下列内容:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoadModule php5_module C:/PHP/php5apache2_4.dll

&amp;lt;IfModule php5_module&amp;gt;
    DirectoryIndex index.html index.php
    AddHandler application/x-httpd-php .php
    PHPIniDir &quot;C:/PHP&quot;
&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入 &lt;code&gt;C:\Apache24\bin&lt;/code&gt;, 运行 &lt;code&gt;httpd.exe&lt;/code&gt;, 如果没有错误产生, 说明配置正常&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;C:\Apache24\htdocs\&lt;/code&gt; 下, 新建一个 &lt;code&gt;phpinfo.php&lt;/code&gt; 文件, 内容如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php phpinfo(); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开 &lt;code&gt;http://localhost/phpinfo.php&lt;/code&gt;, 如果你看到类似如下输出, 说明 PHP 解析正常:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/201604/phpinfoOutput.png&quot; alt=&quot;phpinfo output&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###[可选] 启用 PHP MySql 扩展&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;C:\PHP\php.ini&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;找到 &lt;code&gt;php_mysqli&lt;/code&gt; 或 &lt;code&gt;php_pdo_mysql&lt;/code&gt;, 取消注释&lt;/p&gt;

&lt;p&gt;现在, 你变可以使用 &lt;code&gt;mysqli&lt;/code&gt; 或 &lt;code&gt;PDO&lt;/code&gt; 来操作 MySQL 数据库了&lt;/p&gt;

&lt;p&gt;###安装 MySQL&lt;/p&gt;

&lt;p&gt;双击下载的 MySQL 文件&lt;/p&gt;

&lt;p&gt;选择 Developer default&lt;/p&gt;

&lt;p&gt;安装时会让你配置 root 密码&lt;/p&gt;

&lt;p&gt;安装完后, 可以右击右下角的 MySQL Notifier 图标, 禁用其开机自启动&lt;/p&gt;

&lt;p&gt;###DONE&lt;/p&gt;

&lt;p&gt;你现在已经配置完成整个 WAMP 环境了&lt;/p&gt;

</description>
        <pubDate>Wed, 20 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://panke.me//translation/Install-WAMP</link>
        <guid isPermaLink="true">http://panke.me//translation/Install-WAMP</guid>
        
        <category>wamp</category>
        
        <category>tuts</category>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>IRC 急速入门</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;名词&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IRC&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;一种网络聊天协议&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IRC 网络&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;依据 IRC 协议组成的聊天网络, 
  比较知名的有 &lt;code&gt;freenode&lt;/code&gt;, &lt;code&gt;EFnet&lt;/code&gt;, &lt;code&gt;DALnet&lt;/code&gt; 等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IRC 服务器&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;每个 IRC 网络由多个 IRC 服务器互相连接形成.&lt;/p&gt;

    &lt;p&gt;假设 &lt;code&gt;freenode&lt;/code&gt; 由 A,B,C 三台服务器互联而成,
  那么你随意连接到其中一台便意味着你连接上了 &lt;code&gt;freenode&lt;/code&gt; 网络, 便可进入其中的聊天室聊天&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IRC 聊天室&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;当你连接到 IRC 网络后(比如 &lt;code&gt;freenode&lt;/code&gt;), 便可以进入网络上的聊天室进行聊天.&lt;/p&gt;

    &lt;p&gt;聊天室多以主题为名, 如 &lt;code&gt;#javascript&lt;/code&gt;, &lt;code&gt;#php&lt;/code&gt;, &lt;code&gt;#porn&lt;/code&gt;, &lt;code&gt;#hacker&lt;/code&gt; 等&lt;/p&gt;

    &lt;p&gt;并不是所有的聊天都可以任意进入,
  有些聊天室只能被邀请进入, 有些聊天室只允许已经注册昵称的用户进入, 等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;昵称&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在聊天室, 昵称即你的显示名字, 比如我在 &lt;code&gt;freenode&lt;/code&gt; 的注册昵称就是 &lt;code&gt;UniFreak&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IRC 客户端&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;连接到 IRC 网络需要对应的客户端(就好比浏览网页需要网页客户端, 即浏览器一样)&lt;/p&gt;

    &lt;p&gt;知名的客户端有 mIRC, xChat, HexChat 等&lt;/p&gt;

    &lt;p&gt;下载 HexChat: https://hexchat.github.io/downloads.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IRC 命令&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;使用 IRC 必须掌握几个必须的命令, 命令以 / 开头, 如:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;示例命令&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;/server irc.freenode.net&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;连接到 &lt;code&gt;freenode&lt;/code&gt; 网络&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;/nick myName&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;更换昵称为 myName&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;/msg nickserv register password me@163.com&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;注册昵称, 密码为 password, 邮箱为 me@163.com&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;/join #java&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;进入 #java 聊天室&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;…等等&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;示例&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 hexChat&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置网络&lt;/p&gt;

    &lt;p&gt;首次打开 hexChat 会自动弹出网络配置窗口. 
 也可以使用菜单 &lt;code&gt;HexChat&lt;/code&gt;-&amp;gt;&lt;code&gt;Network Lists&lt;/code&gt; 打开该窗口&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/posts/201604/hexChatServerlist.png&quot; alt=&quot;配置窗口&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;填写自己想要的昵称&lt;/p&gt;

    &lt;p&gt;在 &lt;code&gt;Networks&lt;/code&gt; 的列表中点选 &lt;code&gt;freenode&lt;/code&gt;, 然后点击 &lt;code&gt;Connect&lt;/code&gt; 连接到 &lt;code&gt;freenode&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;连接成功后会弹出此窗口&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/posts/201604/hexChatConnSuccess.png&quot; alt=&quot;连接成功&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;取消选中 &lt;code&gt;always show this ...&lt;/code&gt;, 点击 &lt;code&gt;OK&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现在来到主界面&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/posts/201604/hexChatUI.png&quot; alt=&quot;主界面&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;输入 &lt;code&gt;/msg NickServ register &amp;lt;password&amp;gt; &amp;lt;email&amp;gt;&lt;/code&gt; 以注册当前昵称&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 把 &lt;code&gt;&amp;lt;password&amp;gt;&lt;/code&gt; 换成你自己的密码, 把 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 换成你自己的邮箱地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进入邮箱, 收取邮件. 把邮件中给你的命令粘贴到消息输入框, 回车, 以完成验证&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现在输入命令 &lt;code&gt;/join #irc&lt;/code&gt; 以加入 #irc 聊天室, 在这里你可以问任何有关 irc 的问题. 当然你也可以加入其它感兴趣的聊天室.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开始聊天&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 20 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://panke.me//tutorial/IRC-quick-start</link>
        <guid isPermaLink="true">http://panke.me//tutorial/IRC-quick-start</guid>
        
        <category>irc</category>
        
        <category>tuts</category>
        
        
        <category>tutorial</category>
        
      </item>
    
      <item>
        <title>使用 php printf() 和 sprintf() 格式化字符串</title>
        <description>&lt;p&gt;&lt;em&gt;原文在 2009/11/19 发表于 &lt;a href=&quot;http://www.elated.com/articles/formatting-php-strings-printf-sprintf/&quot;&gt;http://www.elated.com/articles/formatting-php-strings-printf-sprintf/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;和其他许多编程语言一样, PHP 也有功能强大的 [&lt;code&gt;printf()&lt;/code&gt;][printf] 和 [&lt;code&gt;sprintf()&lt;/code&gt;][sprintf] 函数, 它们提供了很多格式化字符串的方式. 当你想要某些数据更易读, 或者需要传递数据给其他程式的时候, 这两个函数很有用.&lt;/p&gt;

&lt;p&gt;PHP 也有许多专门用途的格式化字符串的函数 - 比如 [&lt;code&gt;date()&lt;/code&gt;][date] 函数, 适合用于格式化日期字符串. 而 &lt;code&gt;printf()&lt;/code&gt; 和 &lt;code&gt;sprintf()&lt;/code&gt; 则适合更为通用的格式化.&lt;/p&gt;

&lt;p&gt;这篇教程就会教你如何使用 &lt;code&gt;printf()&lt;/code&gt; 和 &lt;code&gt;sprintf()&lt;/code&gt; 来格式化字符串.&lt;/p&gt;

&lt;p&gt;#一个简单的 &lt;code&gt;printf()&lt;/code&gt; 示例&lt;/p&gt;

&lt;p&gt;了解 &lt;code&gt;printf()&lt;/code&gt; 的最简单方式就是通过示例. 下面这个例子打印一个包含了两个数字的字符串:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 打印 &quot;Australia comprises 6 states and 10 territories&quot;
printf( &quot;Australia comprises %d states and %d territories&quot;, 6, 10 );
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这个字符串在被打印出的时候, 第一个 &lt;code&gt;%d&lt;/code&gt; 被第二个参数 &lt;code&gt;6&lt;/code&gt; 替换, 第二个 &lt;code&gt;%d&lt;/code&gt; 则被第三个参数 &lt;code&gt;10&lt;/code&gt; 替换. 其工作原理即:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一个参数必须是一个字符串, 我们称之为目标字符串. 目标字符串包含普通的字符, 和一些可选的格式说明符 (比如 &lt;code&gt;%d&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有格式说明符都以 &lt;code&gt;%&lt;/code&gt; 开头. 它按对应的顺序以特定方式格式化目标字符串之后的参数, 然后将其插入到最终的字符串中, 并显示到网页.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; 如果想要打印 &lt;code&gt;%&lt;/code&gt; 符, 使用 &lt;code&gt;%%&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;#类型说明符&lt;/p&gt;

&lt;p&gt;上面那个例子使用的 &lt;code&gt;%d&lt;/code&gt; 这个格式说明符, 会将参数按照有符号十进制数字格式化. 这个 &lt;code&gt;d&lt;/code&gt; 被称为类型说明符. &lt;code&gt;printf()&lt;/code&gt; 支持很多类型说明符. 下面是类型说明符的完整列表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型说明符&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为二进制数字(如 &lt;code&gt;10010110&lt;/code&gt;)格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为 ASCII 码值格式化为对应的字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为有符号十进制数字格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为科学计数法(如 &lt;code&gt;1.234e+3&lt;/code&gt;)格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为浮点数字, 并且使用地区设定(如在法国, 逗号被用作小数点)格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;和上面相同, 不过不使用地区设定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为八进制数字格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为字符串格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为无符号十进制数字格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为小写十六进制数字(如 &lt;code&gt;4fdf87&lt;/code&gt;)格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将参数作为大写十六进制数字(如 &lt;code&gt;4FDF87&lt;/code&gt;)格式化&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面是一些类型说明符的示例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
printf( &quot;Here&#39;s the number %s as a float (%f), a binary integer (%b), an octal integer (%o), and a hex integer (%x).&quot;, 543.21, 543.21, 543.21, 543.21, 543.21 );
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码会输出:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Here&#39;s the number 543.21 as a float (543.210000), a binary integer (1000011111), an octal integer (1037), and a hex integer (21f).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#符号说明符&lt;/p&gt;

&lt;p&gt;默认情况下, &lt;code&gt;printf()&lt;/code&gt; 只会在负数前加正负符号:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
printf( &quot;%d&quot;, 36 );   // 输出 &quot;36&quot;
printf( &quot;%d&quot;, -36 );  // 输出 &quot;-36&quot;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你也想让 &lt;code&gt;printf()&lt;/code&gt; 在正数前加符号, 可以在类型说明符前指定一个符号说明符 &lt;code&gt;+&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
printf( &quot;%+d&quot;, 36 );   // 输出 &quot;+36&quot;
printf( &quot;%+d&quot;, -36 );  // 输出 &quot;-36&quot;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#填充&lt;/p&gt;

&lt;p&gt;&lt;code&gt;printf()&lt;/code&gt; 允许你填充目标字符串到指定的长度. 你可以使用任何字符做填充字符, 也可以指定填充左边还是右边. 如果你希望在数字前补 &lt;code&gt;0&lt;/code&gt; 或让字符串右对齐, 填充就派上用场了.&lt;/p&gt;

&lt;p&gt;通过在 &lt;code&gt;%&lt;/code&gt; 前面插入一个填充说明符来指定填充规则. 填充说明符使用以下格式:&lt;/p&gt;

&lt;填充符&gt;&lt;宽度&gt;:

- &lt;填充符&gt; 可以是 `0` 或空格. 如果你不指定则默认使用空格. 如果你想要指定其他填充符, 需在它之前加一个 `&#39;` 字符.

- &lt;宽度&gt; 即想要填充到的宽度. 整数代表左填充, 负数代表右填充.

这是些填充说明符示例:

```php
&lt;?php 
printf( &quot;%04d&quot;, 12 );          // 输出 &quot;0012&quot;
printf( &quot;%04d&quot;, 1234 );        // 输出 &quot;1234&quot;
printf( &quot;%04d&quot;, 12345 );       // 输出 &quot;12345&quot;
printf( &quot;% 10s&quot;, &quot;Hello&quot; );    // 输出 &quot;     Hello&quot;
printf( &quot;%10s&quot;, &quot;Hello&quot; );     // 输出 &quot;     Hello&quot;
printf( &quot;%&#39;*10s&quot;, &quot;Hello&quot; );   // 输出 &quot;*****Hello&quot;
printf( &quot;%&#39;*-10s&quot;, &quot;Hello&quot; );  // 输出 &quot;Hello*****&quot;
?&gt;
```

留意第三个示例, 填充说明符并不会导致目标字符串被截断为 4 个字符. __填充只会在必要处增加字符__

#数字精度

当使用 `f` 或者 `F` 类型说明符格式化浮点数时, PHP 默认会取到小数点后面 6 位:

```php
&lt;?php 
printf( &quot;%f&quot;, 123.456 );  // 输出 &quot;123.456000&quot;
?&gt;
```

如果要指定不同的精度, 就要用到精度说明符了. 精度说明符是一个 `.` 号后跟一个数字, 并应放到类型说明符之前. 如:

```php
&lt;?php 
printf( &quot;%.2f&quot;, 123.456 );   // 输出 &quot;123.46&quot;
printf( &quot;%.10f&quot;, 123.456 );  // 输出 &quot;123.4560000000&quot;
printf( &quot;%.0f&quot;, 123.456 );   // 输出 &quot;123&quot;
 ?&gt;
```

如果你既指定了填充说明符又指定了精度说明符, `printf()` 会将整个数字(包括整数和小数部分)填充到指定长度:

```php
&lt;?php 
printf( &quot;%08.2f&quot;, 123.456 );  // 输出 &quot;00123.46&quot;
 ?&gt;
```

如果你同时使用 `s` 类型说明符和精度说明符, `printf()` 会截断目标字符串到指定的长度:

```php
&lt;?php 
printf( &quot;%.2s&quot;, &quot;Hello&quot; );  // 输出 &quot;He&quot;
 ?&gt;
```

#参数交换

默认情况下, 目标字符串的第一个格式说明符会格式化该字符串后的第一个参数, 目标字符串的第二个格式说明符会格式化该字符串后的第二个参数, 以此类推. 但是你可以更改这个顺序.

要这样做, 在 `%` 符和类型说明符之间插入一个 `$` 号. 如:

```php
&lt;?php 
// 输出 &quot;Australia comprises 10 territories and 6 states&quot;
printf( &#39;Australia comprises %2$d territories and %1$d states&#39;, 6, 10 );
 ?&gt;
```

在上面的例子中, 第一个格式说明符是 `%2$d`. 意即: &quot;将目标字符串后的第二个参数作为十进制整数格式化&quot;. 第二个格式说明符 `%1$d` 即: &quot;将目标字符串后的第一个参数作为十进制整数格式化&quot;. 这样, 参数便以不同与默认的顺序格式化.

在上面的例子中, 格式字符串使用单引号而非双引号包围. 这样是为了阻止 `$` 符号被 PHP 解释为变量名.

#保存格式化后的结果

那 `sprintf()` 又是干嘛的呢? 这个函数和 `printf()` 只有一点不同: 它会将格式化后的结果返回, 而不是直接输出. 这样你就可以将结果赋给变量, 进行其他操作等. 如果你想要在输出它之前进行额外的处理, 或者保存到数据库等, 那这点会很有用. 下面是示例:

```php
&lt;?php 
$result = sprintf( &quot;Australia comprises %d states and %d territories&quot;, 6, 10 );

// 输出 &quot;Australia comprises 6 states and 10 territories&quot;
echo $result;
 ?&gt;
```

#相关函数

其他相关的函数包括 [`fprintf()`][fprintf], 用于将结果写到流(如文件). 还有 [`vprintf()`][vprintf]/[`vsprintf()`][vsprintf]/[`vfprintf()`][vfprintf], 它们使用一个数组参数, 而非参数列表.

[printf]: http://php.net/manual/en/function.printf.php
[date]: http://php.net/manual/en/function.date.php
[sprintf]: http://php.net/manual/en/function.sprintf.php
[fprintf]: http://php.net/manual/en/function.fprintf.php
[vprintf]: http://php.net/manual/en/function.vprintf.php
[vsprintf]: http://php.net/manual/en/function.vsprintf.php
[vfprintf]: http://php.net/manual/en/function.vfprintf.php
&lt;/宽度&gt;&lt;/填充符&gt;&lt;/宽度&gt;&lt;/填充符&gt;
</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://panke.me//translation/Formating_PHP_Strings_With_Printf_And_Sprintf</link>
        <guid isPermaLink="true">http://panke.me//translation/Formating_PHP_Strings_With_Printf_And_Sprintf</guid>
        
        <category>php</category>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>YII(版本1) 权威指南学习笔记(未完结)</title>
        <description>&lt;p&gt;#基础&lt;/p&gt;

&lt;p&gt;##入口脚本&lt;/p&gt;

&lt;p&gt;WEB 应用一般为 &lt;code&gt;index.php&lt;/code&gt;, 控制台应用一般为 &lt;code&gt;yii.php&lt;/code&gt; 并在文件开头加上 &lt;code&gt;#! /usr/bin/env php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;入口脚本是定义全局常量的好地方&lt;/p&gt;

&lt;p&gt;支持三个常量: &lt;code&gt;YII_DEBUG&lt;/code&gt;, &lt;code&gt;YII_ENV&lt;/code&gt;, &lt;code&gt;YII_ENABLE_ERROR_HANDLER&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;WEB:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 定义全局常量
defined(&#39;YII_DEBUG&#39;) or define(&#39;YII_DEBUG&#39;, true);
defined(&#39;YII_ENV&#39;) or define(&#39;YII_ENV&#39;, &#39;dev&#39;);

// 注册 Composer 自动加载器
require(__DIR__ . &#39;/../vendor/autoload.php&#39;);

// 包含 Yii 类文件
require(__DIR__ . &#39;/../vendor/yiisoft/yii2/Yii.php&#39;);

// 加载应用配置
$config = require(__DIR__ . &#39;/../config/web.php&#39;);

// 创建、配置、运行一个应用
(new yii\web\Application($config))-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;控制台:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;#!/usr/bin/env php
&amp;lt;?php
defined(&#39;YII_DEBUG&#39;) or define(&#39;YII_DEBUG&#39;, true);

// fcgi 默认没有定义 STDIN 和 STDOUT
defined(&#39;STDIN&#39;) or define(&#39;STDIN&#39;, fopen(&#39;php://stdin&#39;, &#39;r&#39;));
defined(&#39;STDOUT&#39;) or define(&#39;STDOUT&#39;, fopen(&#39;php://stdout&#39;, &#39;w&#39;));

// 注册 Composer 自动加载器
require(__DIR__ . &#39;/vendor/autoload.php&#39;);

// 包含 Yii 类文件
require(__DIR__ . &#39;/vendor/yiisoft/yii2/Yii.php&#39;);

// 加载应用配置
$config = require(__DIR__ . &#39;/config/console.php&#39;);

$application = new yii\console\Application($config);
$exitCode = $application-&amp;gt;run();
exit($exitCode);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##应用主体&lt;/p&gt;

&lt;p&gt;创建: &lt;code&gt;Yii::createWebApplication($configFile)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;访问: 可以在任何地方使用 &lt;code&gt;Yii::app()|YiiBase::app&lt;/code&gt; 访问&lt;/p&gt;

&lt;p&gt;##控制器&lt;/p&gt;

&lt;p&gt;控制器路由格式: &lt;code&gt;moduleID/controllerID/actionID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;控制器创建决策步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果指定了 &lt;code&gt;CWebApplication::catchAllRequest&lt;/code&gt;, 用户指定的 ID 将被忽略. (通常用于设置应用为维护状态, 显示一个静态页面)&lt;/li&gt;
  &lt;li&gt;如果在 &lt;code&gt;CWebApplication::controllerMap&lt;/code&gt; 中找到 ID, 相应的控制器配置则被用于创建控制器&lt;/li&gt;
  &lt;li&gt;如果 ID 为 &lt;code&gt;path/to/xyz&lt;/code&gt; 形式, 则按控制器路由格式解析并创建&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;创建:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;默认控制器在 &lt;code&gt;CWebApplication::defaultController&lt;/code&gt; 中定义, 默认动作为 &lt;code&gt;index&lt;/code&gt;, 对应的方法名为 &lt;code&gt;actionIndex&lt;/code&gt;, 可通过 &lt;code&gt;CController::defaultAction&lt;/code&gt; 修改&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  class SiteController extends CController {
  }
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;也可以由一个动作类来定义动作, 以便重用动作:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  class UpdateAction extends CAction {
      public function run() {
          // place the action logic here
      }
  }
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后需覆盖控制器类的 &lt;code&gt;actions&lt;/code&gt; 方法:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  class PostController extends CController {
      public function actions() {
          return array(
              &#39;edit&#39;=&amp;gt;&#39;application.controllers.post.UpdateAction&#39;,
          );
      }
  }
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动作参数绑定:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// in PostController:
public function actionCreate(array $category, $language = &#39;en&#39;) {
    // 动作参数绑定功能将会把传入 action 的参数和 $_GET 中的数据绑定
    // 在此, 如果 $_GET 中没有 language 这一项, $language 默认为 &#39;en&#39;
    // 因为没有为 $category 提供默认值, 如果 $_GET 中没有 category 这一项则会报错
    // array 类型声明会确保 $category 为一个数组(自动将基本类型转换为数组)
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;过滤器可被配置在动作执行之前或之后执行, 如访问控制过滤器, 性能过滤器(参见&lt;a href=&quot;#accessControlFilter&quot;&gt;访问控制过滤器&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;定义:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;可被定义为一个 &lt;code&gt;filter&lt;/code&gt; 前缀的控制器方法:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  public function filterAccessControl($filterChain) {
      // 调用 $filterChain-&amp;gt;run() 以继续后续过滤器与动作的执行。
  }
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;也可是一个 &lt;code&gt;CFilter&lt;/code&gt; 或其子类的实例:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```php
  &amp;lt;?php
  class PerformanceFilter extends CFilter {
      protected function preFilter($filterChain) {
          // 动作被执行之前应用的逻辑
          return true; // 如果动作不应被执行，此处返回 false
      }&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  protected function postFilter($filterChain) {
      // 动作执行之后应用的逻辑
  }   }   ?&amp;gt;   ```
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置使用: 需要覆盖控制器的 &lt;code&gt;filter()&lt;/code&gt; 方法:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  class PostController extends CController {
      ......
      public function filters() {
          return array(
              &#39;postOnly + edit, create&#39;, // 使用 filter 前缀方法定义的过滤器
              array(                     // 使用类定义的过滤器
                  &#39;application.filters.PerformanceFilter - edit, create&#39;,
                  &#39;unit&#39;=&amp;gt;&#39;second&#39;,
              ),
          );
      }
  }
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##模型&lt;/p&gt;

&lt;p&gt;Yii 实现了两种类型的模型: 表单模型和 Active Record, 二者都继承于 CModel&lt;/p&gt;

&lt;p&gt;如果用户输入被收集然后丢弃, 应该创建一个表单模型; 如果用户输入被收集后要保存到数据库, 应使用一个 Active Record&lt;/p&gt;

&lt;p&gt;详见&lt;a href=&quot;#FormModel&quot;&gt;表单模型&lt;/a&gt;和&lt;a href=&quot;#ActiveRecord&quot;&gt;Active Record&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##视图&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CController::render(&#39;edit&#39;)&lt;/code&gt; 将会在 &lt;code&gt;protected/views/ControllerID&lt;/code&gt; 目录下寻找 &lt;code&gt;edit.php&lt;/code&gt; 视图文件&lt;/p&gt;

&lt;p&gt;可以通过在视图中使用 &lt;code&gt;$this-&amp;gt;propertyName&lt;/code&gt; 访问控制器的任何属性, 也可以在控制器中将数据传递到视图中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$this-&amp;gt;render(&#39;edit&#39;, array(
    &#39;var1&#39;=&amp;gt;$value1,
    &#39;var2&#39;=&amp;gt;$value2,
));
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;protected/views/layouts/main.php&lt;/code&gt; 是默认的&lt;code&gt;布局&lt;/code&gt;文件, 可通过 &lt;code&gt;CWebApplication::layout&lt;/code&gt; 自定义. 要渲染一个不带布局的视图, 需调用 &lt;code&gt;CController::renderPartial&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;小物件&lt;/code&gt;是 &lt;code&gt;CWidget&lt;/code&gt; 或其子类的实例, 它也可以有自己的视图文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;定义&lt;/p&gt;

    &lt;p&gt;```php
  &amp;lt;?php
  class MyWidget extends CWidget {
      public function init() {
          // 此方法会被 CController::beginWidget() 调用
      }&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  public function run() {
      // 此方法会被 CController::endWidget() 调用
  }   }   ?&amp;gt;   ```
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;按如下视图脚本来使用一个小物件:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php $this-&amp;gt;beginWidget(&#39;path.to.WidgetClass&#39;, $config); ?&amp;gt;
  ...可能会由小物件获取的内容主体...
  &amp;lt;?php $this-&amp;gt;endWidget(); ?&amp;gt;
  // 或
  &amp;lt;?php $this-&amp;gt;widget(&#39;path.to.WidgetClass&#39;, $config); ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;系统视图用于展示 Yii 的错误和日志消息, 如如果 CHttpException 抛出一个 404 错误, 那么 &lt;code&gt;error404&lt;/code&gt; 就会被展示. Yii 在 &lt;code&gt;framework/views&lt;/code&gt; 下提供了默认的系统视图, 也可以通过在 &lt;code&gt;protected/views/system&lt;/code&gt; 下创建同名视图文件进行自定义&lt;/p&gt;

&lt;p&gt;##组件&lt;/p&gt;

&lt;p&gt;加载: 通过配置应用的 &lt;code&gt;components|CApplication::components&lt;/code&gt; 属性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以配置 &lt;code&gt;enabled&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 禁用组件&lt;/li&gt;
  &lt;li&gt;组件是按需创建的, 但是可以将组件 ID 列入应用的 &lt;code&gt;preload|CWebApplication::preload&lt;/code&gt; 属性中强制其加载&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;访问: &lt;code&gt;Yii::app()-&amp;gt;ComponentID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;预定义的核心应用组件:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assetManager&lt;/li&gt;
  &lt;li&gt;authManager&lt;/li&gt;
  &lt;li&gt;cache&lt;/li&gt;
  &lt;li&gt;clientScript&lt;/li&gt;
  &lt;li&gt;coreMessage&lt;/li&gt;
  &lt;li&gt;db&lt;/li&gt;
  &lt;li&gt;errorHandler&lt;/li&gt;
  &lt;li&gt;format&lt;/li&gt;
  &lt;li&gt;messages&lt;/li&gt;
  &lt;li&gt;request&lt;/li&gt;
  &lt;li&gt;securityManager&lt;/li&gt;
  &lt;li&gt;session&lt;/li&gt;
  &lt;li&gt;statePersister&lt;/li&gt;
  &lt;li&gt;urlManager&lt;/li&gt;
  &lt;li&gt;user&lt;/li&gt;
  &lt;li&gt;themeManager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组件属性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以通过直接定义一个公共成员变量定义&lt;/li&gt;
  &lt;li&gt;也可以使用 getter 和 setter 更灵活的定义&lt;/li&gt;
  &lt;li&gt;通过 getter 和 setter 定义的属性和类成员变量有个区别: 他们是不区分大小写的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组件事件&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;定义组件事件(&lt;code&gt;on&lt;/code&gt; 开头)&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 public function onClicked($event) {
     $this-&amp;gt;raiseEvent(&#39;onClicked&#39;, $event);
 }
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;定义事件回调&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 function callbackName($event) {
     ......
 }
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绑定事件回调&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 $component-&amp;gt;onClicked=$callback;
 // 或使用匿名函数
 $component-&amp;gt;onclicked=function($event) {
 }
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组件行为&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;行为类必须实现 &lt;code&gt;IBehavior&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大多数行为可继承自 &lt;code&gt;CBehavior&lt;/code&gt;, 如果行为需要绑定到模型, 则也可以继承自 &lt;code&gt;CModelBehavior&lt;/code&gt; 或 &lt;code&gt;CActiveRecordBehavior&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;两个同名行为绑定到同一个组件下是有可能的, 在这种情况下, 先绑定的行为则拥有优先权&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当和 events, 一起使用时, 行为会更加强大. 当行为被绑定到组件时,行为里的一些方法就可以绑定到组件的一些事件上了. 这样一来,行为就有机观察或者改变组件的常规执行流程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个行为的属性也可以通过绑定到的组件来访问. 这些属性包含公共成员变量以及通过 getters 和/或 setters 方式设置的属性. 例如, 若一个行为有一个 &lt;code&gt;xyz&lt;/code&gt; 的属性，此行为被绑定到组件 &lt;code&gt;$a&lt;/code&gt;, 然后我们可以使用表达式 &lt;code&gt;$a-&amp;gt;xyz&lt;/code&gt; 访问此行为的属性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绑定行为:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  // $name 在组件中实现了对行为的唯一识别
  $component-&amp;gt;attachBehavior($name,$behavior);
  // test() 是行为中的方法。
  $component-&amp;gt;test();
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问行为:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  $behavior=$component-&amp;gt;tree;
  // 等于下行代码：
  // $behavior=$component-&amp;gt;asa(&#39;tree&#39;);
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;禁用行为:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  $component-&amp;gt;disableBehavior($name);
  // 下面的代码将抛出一个异常
  $component-&amp;gt;test();
  $component-&amp;gt;enableBehavior($name);
  // 现在就可以使用了
  $component-&amp;gt;test();
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##模块&lt;/p&gt;

&lt;p&gt;模块是一个独立的软件单元，它包含 模型, 视图, 控制器 和其他支持的组件. 如 &lt;code&gt;forum&lt;/code&gt; 模块的典型目录结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forum/
   ForumModule.php            模块类文件
   components/                包含可复用的用户组件
      views/                  包含小物件的视图文件
   controllers/               包含控制器类文件
      DefaultController.php   默认的控制器类文件
   extensions/                包含第三方扩展
   models/                    包含模块类文件
   views/                     包含控制器视图和布局文件
      layouts/                包含布局文件
      default/                包含 DefaultController 的视图文件
         index.php            首页视图文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块可以嵌套&lt;/p&gt;

&lt;p&gt;使用模块:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;继承 CWebModule, 并命名为 ucfirst($id).’Module’&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将模块目录放入 &lt;code&gt;modules&lt;/code&gt; 目录中, 然后在应用的 &lt;code&gt;modules&lt;/code&gt; 配置 属性中声明模块 ID. 模块也可以在配置是带有初始属性值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 CController::module 访问&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##路径别名和名字空间&lt;/p&gt;

&lt;p&gt;&lt;code&gt;YiiBase::getPathOfAlias()&lt;/code&gt; 获取别名的真实路径, &lt;code&gt;YiiBase::setPathOfAlias()&lt;/code&gt; 设置新的别名的真实路径&lt;/p&gt;

&lt;p&gt;预定义的根别名&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;system&lt;/li&gt;
  &lt;li&gt;zii&lt;/li&gt;
  &lt;li&gt;application&lt;/li&gt;
  &lt;li&gt;webroot&lt;/li&gt;
  &lt;li&gt;ext&lt;/li&gt;
  &lt;li&gt;模块 ID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用别名导入类: &lt;code&gt;Yii::import(&#39;system.web.CController&#39;)&lt;/code&gt;. (所有核心类已被预先导入)&lt;/p&gt;

&lt;p&gt;预导入: 在 &lt;code&gt;CWebApplication::run()&lt;/code&gt; 之前执行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
Yii::$classMap=array(
    &#39;ClassName1&#39; =&amp;gt; &#39;path/to/ClassName1.php&#39;,
    &#39;ClassName2&#39; =&amp;gt; &#39;path/to/ClassName2.php&#39;,
    ......
);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入目录: &lt;code&gt;Yii::import(&#39;system.web.*&#39;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;#&lt;a name=&quot;FormModel&quot;&gt;使用表单&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##创建模型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
class LoginForm extends CFormModel {
    // 定义特性(我们把用于存储用户输入或数据库数据的属性成为特性(attribute))
    public $username;
    public $password;
    public $rememberMe=false;

    private $_identity;

    // 验证规则
    public function rules() {
        /**
         * 每个验证规则的格式为: 
         * array(&#39;AttributeList&#39;, &#39;Validator&#39;, &#39;on&#39;=&amp;gt;&#39;ScenarioList&#39;, ...附加选项)
         * 有三种方法指定 Validator
         * 1. 指定为模型类中的一个方法, 该方法定义格式为
         * public function ValidatiorName($attributes, $params) {...}
         * 2. 一个继承自 CValidator 的验证器类, 此时附加选项用于初始化实例的属性值
         * 3. 一个预定义的验证器类的别名, 以下是完整列表
         * boolean, captcha, compare, email, default, exists, file
         * filter, in, length, match, numerical, required, type, unique, url
         */
        return array(
            array(&#39;username, password&#39;, &#39;required&#39;), // 必填
            array(&#39;rememberMe&#39;, &#39;boolean&#39;),          // 布尔
            array(&#39;password&#39;, &#39;authenticate&#39;),       // 需验证
        );
    }

    /**
     * authenticate Validator
     */
    public function authenticate($attribute,$params)
    {
        $this-&amp;gt;_identity=new UserIdentity($this-&amp;gt;username,$this-&amp;gt;password);
        if(!$this-&amp;gt;_identity-&amp;gt;authenticate())
            $this-&amp;gt;addError(&#39;password&#39;,&#39;错误的用户名或密码。&#39;);
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&quot;massiveAssign&quot;&gt;块赋值(massive assignment)&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$model = new LoginForm();
if (isset($_POST[&#39;LoginForm&#39;])) {
    /**
     * 只有被认为 &#39;安全&#39; 的特性才会被赋值
     * 特性如果出现在相应场景的一个验证规则中, 即被认为是安全的
     * 也可以用特殊的 `safe` Validator 来让特性变为安全的
     * 
     * 为了使块赋值正确工作, 对应于模型类 `C` 中的特性 `a` 的表单域, 请命名其为  `C[a]`
     */
    $model-&amp;gt;attributes = $_POST[&#39;LoginForm&#39;];
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&quot;triggerValidation&quot;&gt;触发验证&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;验证是基于 &lt;code&gt;场景(scenario)&lt;/code&gt; 的&lt;/li&gt;
  &lt;li&gt;可以手动调用 &lt;code&gt;CModel::validate()&lt;/code&gt; 触发; 对于 &lt;code&gt;CActiveRecord&lt;/code&gt;, 会在 &lt;code&gt;CAcitveRecord::save()&lt;/code&gt; 时自动触发验证&lt;/li&gt;
  &lt;li&gt;验证错误可以使用 &lt;code&gt;CModel::getError()&lt;/code&gt; 或 &lt;code&gt;CModel::getErrors()&lt;/code&gt; 获取&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标签&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;CModel&lt;/code&gt; 默认将返回特性的名字作为其标签&lt;/li&gt;
  &lt;li&gt;也可使用 &lt;code&gt;CModel::attributesLabels&lt;/code&gt; 方法自定义标签&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##创建动作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
public function actionLogin() {
    $model=new LoginForm;
    if(isset($_POST[&#39;LoginForm&#39;])) {
        // 收集用户输入的数据
        $model-&amp;gt;attributes=$_POST[&#39;LoginForm&#39;];
        // 验证用户输入，并在判断输入正确后重定向到前一页
        if($model-&amp;gt;validate())
            $this-&amp;gt;redirect(Yii::app()-&amp;gt;user-&amp;gt;returnUrl);
    }
    // 显示登录表单
    $this-&amp;gt;render(&#39;login&#39;,array(&#39;model&#39;=&amp;gt;$model));
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##创建视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;div class=&quot;form&quot;&amp;gt;
&amp;lt;?php $form=$this-&amp;gt;beginWidget(&#39;CActiveForm&#39;); ?&amp;gt;

    &amp;lt;?php echo $form-&amp;gt;errorSummary($model); ?&amp;gt;

    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;?php echo $form-&amp;gt;label($model,&#39;username&#39;); ?&amp;gt;
        &amp;lt;?php echo $form-&amp;gt;textField($model,&#39;username&#39;) ?&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;?php echo $form-&amp;gt;label($model,&#39;password&#39;); ?&amp;gt;
        &amp;lt;?php echo $form-&amp;gt;passwordField($model,&#39;password&#39;) ?&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&quot;row rememberMe&quot;&amp;gt;
        &amp;lt;?php echo $form-&amp;gt;checkBox($model,&#39;rememberMe&#39;); ?&amp;gt;
        &amp;lt;?php echo $form-&amp;gt;label($model,&#39;rememberMe&#39;); ?&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&quot;row submit&quot;&amp;gt;
        &amp;lt;?php echo CHtml::submitButton(&#39;Login&#39;); ?&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;?php $this-&amp;gt;endWidget(); ?&amp;gt;
&amp;lt;/div&amp;gt;&amp;lt;!-- form --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##收集表格输入(批量)&lt;/p&gt;

&lt;p&gt;action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
public function actionBatchUpdate()
{
    // 假设每一项（item）是一个 &#39;Item&#39; 类的实例，
    // 提取要通过批量模式更新的项
    $items=$this-&amp;gt;getItemsToUpdate();
    if(isset($_POST[&#39;Item&#39;]))
    {
        $valid=true;
        foreach($items as $i=&amp;gt;$item)
        {
            if(isset($_POST[&#39;Item&#39;][$i]))
                $item-&amp;gt;attributes=$_POST[&#39;Item&#39;][$i];
            $valid=$valid &amp;amp;&amp;amp; $item-&amp;gt;validate();
        }
        if($valid)  // 如果所有项目有效
            // ...则在此处做一些操作
    }
    // 显示视图收集表格输入
    $this-&amp;gt;render(&#39;batchUpdate&#39;,array(&#39;items&#39;=&amp;gt;$items));
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;view:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;div class=&quot;form&quot;&amp;gt;
&amp;lt;?php echo CHtml::beginForm(); ?&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Price&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Count&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Description&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;?php foreach($items as $i=&amp;gt;$item): ?&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;?php echo CHtml::activeTextField($item,&quot;[$i]name&quot;); ?&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;?php echo CHtml::activeTextField($item,&quot;[$i]price&quot;); ?&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;?php echo CHtml::activeTextField($item,&quot;[$i]count&quot;); ?&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;?php echo CHtml::activeTextArea($item,&quot;[$i]description&quot;); ?&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;?php endforeach; ?&amp;gt;
&amp;lt;/table&amp;gt;

&amp;lt;?php echo CHtml::submitButton(&#39;Save&#39;); ?&amp;gt;
&amp;lt;?php echo CHtml::endForm(); ?&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##使用表单生成器 @todo&lt;/p&gt;

&lt;p&gt;action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
public function actionLogin() {
    $model = new LoginForm;
    $form = new CForm(&#39;application.views.site.loginForm&#39;, $model);
    if($form-&amp;gt;submitted(&#39;login&#39;) &amp;amp;&amp;amp; $form-&amp;gt;validate()) {
        $this-&amp;gt;redirect(array(&#39;site/index&#39;));
    } else {
        $this-&amp;gt;render(&#39;login&#39;, array(&#39;form&#39;=&amp;gt;$form));
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;protected/views/site/loginForm.php:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
return array(
    &#39;title&#39;=&amp;gt;&#39;Please provide your login credential&#39;,

    &#39;elements&#39;=&amp;gt;array(
        &#39;username&#39;=&amp;gt;array(
            // 可选 type: text, hidden, password, textarea, file, radio
            // checkbox, listbox, dropdownlist, checkboxlist, radiolist
            &#39;type&#39;=&amp;gt;&#39;text&#39;,
            &#39;maxlength&#39;=&amp;gt;32,
        ),
        &#39;password&#39;=&amp;gt;array(
            &#39;type&#39;=&amp;gt;&#39;password&#39;,
            &#39;maxlength&#39;=&amp;gt;32,
        ),
        &#39;rememberMe&#39;=&amp;gt;array(
            &#39;type&#39;=&amp;gt;&#39;checkbox&#39;,
        )
    ),

    &#39;buttons&#39;=&amp;gt;array(
        &#39;login&#39;=&amp;gt;array(
            &#39;type&#39;=&amp;gt;&#39;submit&#39;,
            &#39;label&#39;=&amp;gt;&#39;Login&#39;,
        ),
    ),
);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;view:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;h1&amp;gt;Login&amp;lt;/h1&amp;gt;

&amp;lt;div class=&quot;form&quot;&amp;gt;
&amp;lt;?php echo $form; ?&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#使用数据库&lt;/p&gt;

&lt;p&gt;##数据访问对象(DAO)&lt;/p&gt;

&lt;p&gt;建立数据库连接:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 &lt;code&gt;CDbConnection&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$connection=new CDbConnection($dsn,$username,$password);
// 建立连接。你可以使用  try...catch 捕获可能抛出的异常
$connection-&amp;gt;active=true;
......
$connection-&amp;gt;active=false;  // 关闭连接
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;作为应用组件配置, 然后使用 &lt;code&gt;Yii::app()-&amp;gt;db&lt;/code&gt; 访问&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
array(
    ......
    &#39;components&#39;=&amp;gt;array(
        ......
        &#39;db&#39;=&amp;gt;array(
            &#39;class&#39;=&amp;gt;&#39;CDbConnection&#39;,
            &#39;connectionString&#39;=&amp;gt;&#39;mysql:host=localhost;dbname=testdb&#39;,
            &#39;username&#39;=&amp;gt;&#39;root&#39;,
            &#39;password&#39;=&amp;gt;&#39;password&#39;,
            &#39;emulatePrepare&#39;=&amp;gt;true,  // needed by some MySQL installations
        ),
    ),
)
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##执行 SQL 语句&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建 &lt;code&gt;CDbCommand&lt;/code&gt; 实例&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 $connection=Yii::app()-&amp;gt;db;   // 假设你已经建立了一个 &quot;db&quot; 连接
 // 如果没有，你可能需要显式建立一个连接：
 // $connection=new CDbConnection($dsn,$username,$password);
 $command=$connection-&amp;gt;createCommand($sql);
 // 如果需要，此 SQL 语句可通过如下方式修改：
 // $command-&amp;gt;text=$newSQL;
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用以下方法执行语句&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 $rowCount=$command-&amp;gt;execute();   // 执行无查询 SQL(Insert, delete, update)
 $dataReader=$command-&amp;gt;query();   // 执行一个 SQL 查询(select), 返回 CDbDataReader 实例
 $rows=$command-&amp;gt;queryAll();      // 查询并返回结果中的所有行
 $row=$command-&amp;gt;queryRow();       // 查询并返回结果中的第一行
 $column=$command-&amp;gt;queryColumn(); // 查询并返回结果中的第一列
 $value=$command-&amp;gt;queryScalar();  // 查询并返回结果中第一行的第一个字段
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取查询结果&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 $dataReader=$command-&amp;gt;query();
 // 重复调用 read() 直到它返回 false
 while(($row=$dataReader-&amp;gt;read())!==false) { ... }
 // 或使用 foreach 遍历数据中的每一行
 foreach($dataReader as $row) { ... }
 // 一次性提取所有行到一个数组
 $rows=$dataReader-&amp;gt;readAll();
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用事务&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 $transaction=$connection-&amp;gt;beginTransaction();
 try {
     $connection-&amp;gt;createCommand($sql1)-&amp;gt;execute();
     $connection-&amp;gt;createCommand($sql2)-&amp;gt;execute();
     //.... other SQL executions
     $transaction-&amp;gt;commit();
 } catch(Exception $e) { // 如果有一条查询失败，则会抛出异常
     $transaction-&amp;gt;rollBack();
 }
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 Prepare Statment&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 // 一条带有两个占位符 &quot;:username&quot; 和 &quot;:email&quot;的 SQL
 $sql=&quot;INSERT INTO tbl_user (username, email) VALUES(:username,:email)&quot;;
 $command=$connection-&amp;gt;createCommand($sql);
 // 用实际的用户名替换占位符 &quot;:username&quot; 
 $command-&amp;gt;bindParam(&quot;:username&quot;,$username,PDO::PARAM_STR);
 // 用实际的 Email 替换占位符 &quot;:email&quot; 
 $command-&amp;gt;bindParam(&quot;:email&quot;,$email,PDO::PARAM_STR);
 $command-&amp;gt;execute();
 // 使用新的参数集插入另一行
 $command-&amp;gt;bindParam(&quot;:username&quot;,$username2,PDO::PARAM_STR);
 $command-&amp;gt;bindParam(&quot;:email&quot;,$email2,PDO::PARAM_STR);
 $command-&amp;gt;execute();
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绑定结果列&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
 &amp;lt;?php
 $sql=&quot;SELECT username, email FROM tbl_user&quot;;
 $dataReader=$connection-&amp;gt;createCommand($sql)-&amp;gt;query();
 // 使用 $username 变量绑定第一列 (username) 
 $dataReader-&amp;gt;bindColumn(1,$username);
 // 使用 $email 变量绑定第二列 (email) 
 $dataReader-&amp;gt;bindColumn(2,$email);
 while($dataReader-&amp;gt;read()!==false) {
     // $username 和 $email 含有当前行中的 username 和 email 
 }
 ?&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用表前缀&lt;/p&gt;

    &lt;p&gt;配置 &lt;code&gt;CDbConnection::tablePrefix&lt;/code&gt; 属性为所希望的表前缀, 然后便可以在 SQL 语句中使用 `` 代表表的名字&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##查询构建器&lt;/p&gt;

&lt;p&gt;查询构建器构建于一个 &lt;code&gt;CDbCommand&lt;/code&gt; 实例上&lt;/p&gt;

&lt;p&gt;查询构建器不能用于修改一个已经存在的 SQL 查询&lt;/p&gt;

&lt;p&gt;可用的查询构建器示例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 1. 数据查询

// SELECT *
select()
// SELECT `id`, `username`
select(&#39;id, username&#39;)
// SELECT `tbl_user`.`id`, `username` AS `name`
select(&#39;tbl_user.id, username as name&#39;)
// SELECT `id`, `username`
select(array(&#39;id&#39;, &#39;username&#39;))
// SELECT `id`, count(*) as num
select(array(&#39;id&#39;, &#39;count(*) as num&#39;))

// SELECT DISTINCT `id`, `username`
selectDistinct(&#39;id, username&#39;)

// FROM `tbl_user`
from(&#39;tbl_user&#39;)
// FROM `tbl_user` `u`, `public`.`tbl_profile` `p`
from(&#39;tbl_user u, public.tbl_profile p&#39;)
// FROM `tbl_user`, `tbl_profile`
from(array(&#39;tbl_user&#39;, &#39;tbl_profile&#39;))
// FROM `tbl_user`, (select * from tbl_profile) p
from(array(&#39;tbl_user&#39;, &#39;(select * from tbl_profile) p&#39;))

// WHERE id=1 or id=2
where(&#39;id=1 or id=2&#39;)
// WHERE id=:id1 or id=:id2
where(&#39;id=:id1 or id=:id2&#39;, array(&#39;:id1&#39;=&amp;gt;1, &#39;:id2&#39;=&amp;gt;2))
// WHERE id=1 OR id=2
where(array(&#39;or&#39;, &#39;id=1&#39;, &#39;id=2&#39;))
// WHERE id=1 AND (type=2 OR type=3)
where(array(&#39;and&#39;, &#39;id=1&#39;, array(&#39;or&#39;, &#39;type=2&#39;, &#39;type=3&#39;)))
// WHERE `id` IN (1, 2)
where(array(&#39;in&#39;, &#39;id&#39;, array(1, 2))
// WHERE `id` NOT IN (1, 2)
where(array(&#39;not in&#39;, &#39;id&#39;, array(1,2)))
// when using LIKE, remember to escape user inputed `%` and `_`
// WHERE `name` LIKE &#39;%Qiang%&#39;
where(array(&#39;like&#39;, &#39;name&#39;, &#39;%Qiang%&#39;))
// WHERE `name` LIKE &#39;%Qiang&#39; AND `name` LIKE &#39;%Xue&#39;
where(array(&#39;like&#39;, &#39;name&#39;, array(&#39;%Qiang&#39;, &#39;%Xue&#39;)))
// WHERE `name` LIKE &#39;%Qiang&#39; OR `name` LIKE &#39;%Xue&#39;
where(array(&#39;or like&#39;, &#39;name&#39;, array(&#39;%Qiang&#39;, &#39;%Xue&#39;)))
// WHERE `name` NOT LIKE &#39;%Qiang%&#39;
where(array(&#39;not like&#39;, &#39;name&#39;, &#39;%Qiang%&#39;))
// WHERE `name` NOT LIKE &#39;%Qiang%&#39; OR `name` NOT LIKE &#39;%Xue%&#39;
where(array(&#39;or not like&#39;, &#39;name&#39;, array(&#39;%Qiang%&#39;, &#39;%Xue%&#39;)))

// WHERE ... OR ...
orWhere()

// WHERE ... AND ...
andWhere()

// ORDER BY `name`, `id` DESC
order(&#39;name, id desc&#39;)
// ORDER BY `tbl_profile`.`name`, `id` DESC
order(array(&#39;tbl_profile.name&#39;, &#39;id desc&#39;))

// LIMIT 10
limit(10)
// LIMIT 10 OFFSET 20
limit(10, 20)

// OFFSET 20
offset(20)

// JOIN `tbl_profile` ON user_id=id
join(&#39;tbl_profile&#39;, &#39;user_id=id&#39;)

// LEFT JOIN `pub`.`tbl_profile` `p` ON p.user_id=id AND type=1
leftJoin(&#39;pub.tbl_profile p&#39;, &#39;p.user_id=id AND type=:type&#39;, array(&#39;:type&#39;=&amp;gt;1))

// RIGHT JOIN
rightJoin()

// CROSS JOIN
crossJoin()

// NATURAL JOIN
natrualJoin()

// GROUP BY `name`, `id`
group(&#39;name, id&#39;)
// GROUP BY `tbl_profile`.`name`, `id`
group(array(&#39;tbl_profile.name&#39;, &#39;id&#39;))

// HAVING id=1 or id=2
having(&#39;id=1 or id=2&#39;)
// HAVING id=1 OR id=2
having(array(&#39;or&#39;, &#39;id=1&#39;, &#39;id=2&#39;))

// UNION (select * from tbl_profile)
union(&#39;select * from tbl_profile&#39;)

// 2. 数据操作(不同于数据查询, 数据操作会立即执行)

// INSERT INTO `tbl_user` (`name`, `email`) VALUES (:name, :email)
$command-&amp;gt;insert(&#39;tbl_user&#39;, array(
    &#39;name&#39;=&amp;gt;&#39;Tester&#39;,
    &#39;email&#39;=&amp;gt;&#39;tester@example.com&#39;,
));

// UPDATE `tbl_user` SET `name`=:name WHERE id=:id
$command-&amp;gt;update(&#39;tbl_user&#39;, array(
    &#39;name&#39;=&amp;gt;&#39;Tester&#39;,
), &#39;id=:id&#39;, array(&#39;:id&#39;=&amp;gt;1));

// DELETE FROM `tbl_user` WHERE id=:id
$command-&amp;gt;delete(&#39;tbl_user&#39;, &#39;id=:id&#39;, array(&#39;:id&#39;=&amp;gt;1));

// 3. Schema 操作

// CREATE TABLE `tbl_user` (
//     `id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
//     `username` varchar(255) NOT NULL,
//     `location` point
// ) ENGINE=InnoDB
createTable(&#39;tbl_user&#39;, array(
    &#39;id&#39; =&amp;gt; &#39;pk&#39;,
    &#39;username&#39; =&amp;gt; &#39;string NOT NULL&#39;,
    &#39;location&#39; =&amp;gt; &#39;point&#39;,
), &#39;ENGINE=InnoDB&#39;)

// RENAME TABLE `tbl_users` TO `tbl_user`
renameTable(&#39;tbl_users&#39;, &#39;tbl_user&#39;)

// DROP TABLE `tbl_user`
dropTable(&#39;tbl_user&#39;)

// TRUNCATE TABLE `tbl_user`
truncateTable(&#39;tbl_user&#39;)

// ALTER TABLE `tbl_user` ADD `email` varchar(255) NOT NULL
addColumn(&#39;tbl_user&#39;, &#39;email&#39;, &#39;string NOT NULL&#39;)

// ALTER TABLE `tbl_user` DROP COLUMN `location`
dropColumn(&#39;tbl_user&#39;, &#39;location&#39;)

// ALTER TABLE `tbl_users` CHANGE `name` `username` varchar(255) NOT NULL
renameColumn(&#39;tbl_user&#39;, &#39;name&#39;, &#39;username&#39;)

// ALTER TABLE `tbl_user` CHANGE `username` `username` varchar(255) NOT NULL
alterColumn(&#39;tbl_user&#39;, &#39;username&#39;, &#39;string NOT NULL&#39;)

// ALTER TABLE `tbl_profile` ADD CONSTRAINT `fk_profile_user_id`
// FOREIGN KEY (`user_id`) REFERENCES `tbl_user` (`id`)
// ON DELETE CASCADE ON UPDATE CASCADE
addForeignKey(&#39;fk_profile_user_id&#39;, &#39;tbl_profile&#39;, &#39;user_id&#39;,
    &#39;tbl_user&#39;, &#39;id&#39;, &#39;CASCADE&#39;, &#39;CASCADE&#39;)

// ALTER TABLE `tbl_profile` DROP FOREIGN KEY `fk_profile_user_id`
dropForeignKey(&#39;fk_profile_user_id&#39;, &#39;tbl_profile&#39;)

// CREATE INDEX `idx_username` ON `tbl_user` (`username`)
createIndex(&#39;idx_username&#39;, &#39;tbl_user&#39;, &#39;username&#39;)

// DROP INDEX `idx_username` ON `tbl_user`
dropIndex(&#39;idx_username&#39;, &#39;tbl_user&#39;)
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可通过使用属性赋值方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$command-&amp;gt;select = array(&#39;id&#39;, &#39;username&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或在创建 &lt;code&gt;CDbCommand&lt;/code&gt; 是传配置参数的方式构建:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$row = Yii::app()-&amp;gt;db-&amp;gt;createCommand(array(
    &#39;select&#39; =&amp;gt; array(&#39;id&#39;, &#39;username&#39;),
    &#39;from&#39; =&amp;gt; &#39;tbl_user&#39;,
    &#39;where&#39; =&amp;gt; &#39;id=:id&#39;,
    &#39;params&#39; =&amp;gt; array(&#39;:id&#39;=&amp;gt;1),
))-&amp;gt;queryRow();
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建完成后, 可以使用在&lt;a href=&quot;#runSql&quot;&gt;执行 SQL 语句&lt;/a&gt;中讲到的方法执行之; 也可使用 &lt;code&gt;CDbCommand::getText()&lt;/code&gt; 获取最后构建完工后的 SQL 语句, 绑定的参数被保存在 &lt;code&gt;CDbCommand::params&lt;/code&gt; 中&lt;/p&gt;

&lt;p&gt;同一个 &lt;code&gt;CDbCommand&lt;/code&gt; 实例可用于多次构建不同的查询, 但是记得要再另一次之前调用 &lt;code&gt;CDbCommand::reset()&lt;/code&gt; 以清理上次的查询&lt;/p&gt;

&lt;p&gt;##&lt;a name=&quot;ActiveRecord&quot;&gt;Active Record&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;每个 AR 类代表一个数据表(或视图), 数据表(或视图)的列在 AR 类中体现为类的属性, 一个 AR 实例则表示表中的一行&lt;/p&gt;

&lt;p&gt;最佳应用是模型化数据表为 PHP 结构和执行不包含复杂 SQL 语句的查询. 对于复杂查询的场景, 应使用 Yii DAO&lt;/p&gt;

&lt;p&gt;如果你数据库的表结构很少改动, 你应该通过配置 &lt;code&gt;CDbConnection::schemaCachingDuration&lt;/code&gt; 属性的值为一个大于零的值开启表结构缓存&lt;/p&gt;

&lt;p&gt;通过 AR 使用多个数据库有两种方式. 如果数据库的结构不同, 你可以创建不同的 AR 基类实现不同的 &lt;code&gt;getDbConnection()&lt;/code&gt;; 否则, 动态改变静态变量 &lt;code&gt;CActiveRecord::db&lt;/code&gt; 是一个好主意&lt;/p&gt;

&lt;p&gt;由于 AR 类经常在多处被引用, 我们可以导入包含 AR 类的整个目录, 而不是一个个导入. 见&lt;a href=&quot;#&quot;&gt;路径别名和命名空间&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过 Yii 的日志功能, 可以查看 AR 在背后到底执行了那些语句&lt;/p&gt;

&lt;p&gt;定义 AR 类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
class Post extends CActiveRecord {
    public static function model($className=__CLASS__) {
        return parent::model($className);
    }

    /**
     * 默认情况下, AR 类的名字和数据表的名字相同. 如果不同, 请覆盖 `CActiveRecord::tableName` 方法
     */
    public function tableName() {
        return &#39;tbl_post&#39;;
    }

    /**
     * AR 依靠表中良好定义的主键. 如果一个表没有主键，则必须在相应的 AR 类中通过如下方式覆盖 primaryKey() 方法指定哪一列或哪几列作为主键:
     */
    public function primaryKey() {
        return &#39;id&#39;;
        // 对于复合主键，要返回一个类似如下的数组
        // return array(&#39;pk1&#39;, &#39;pk2&#39;);
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建记录:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果表的主键是自增的, 在插入完成后, AR 实例将包含一个更新的主键&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$post=new Post;
$post-&amp;gt;title=&#39;sample post&#39;;
$post-&amp;gt;content=&#39;content for the sample post&#39;;
// 如果要使用 Mysql 的 NOW(), 必须使用 CDbExpression, 单纯的 &#39;NOW()&#39; 将会被作为字符串对待
$post-&amp;gt;create_time=new CDbExpression(&#39;NOW()&#39;);
$post-&amp;gt;save();
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读取记录:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;find&lt;/code&gt; 系列返回一个 AR 实例, 或者 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;findAll&lt;/code&gt; 系列返回 AR 实例数组, 或者空数组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 1. 常规
// 查找满足指定条件的结果中的第一行
$post=Post::model()-&amp;gt;find($condition,$params);
$post=Post::model()-&amp;gt;find(&#39;postID=:postID&#39;, array(&#39;:postID&#39;=&amp;gt;10));
// 查找具有指定主键值的那一行
$post=Post::model()-&amp;gt;findByPk($postID,$condition,$params);
// 查找具有指定属性值的行
$post=Post::model()-&amp;gt;findByAttributes($attributes,$condition,$params);
// 通过指定的 SQL 语句查找结果中的第一行
$post=Post::model()-&amp;gt;findBySql($sql,$params);

// 查找满足指定条件的所有行
$posts=Post::model()-&amp;gt;findAll($condition,$params);
// 查找带有指定主键的所有行
$posts=Post::model()-&amp;gt;findAllByPk($postIDs,$condition,$params);
// 查找带有指定属性值的所有行
$posts=Post::model()-&amp;gt;findAllByAttributes($attributes,$condition,$params);
// 通过指定的SQL语句查找所有行
$posts=Post::model()-&amp;gt;findAllBySql($sql,$params);

// 获取满足指定条件的行数
$n=Post::model()-&amp;gt;count($condition,$params);
// 通过指定的 SQL 获取结果行数
$n=Post::model()-&amp;gt;countBySql($sql,$params);
// 检查是否至少有一行复合指定的条件
$exists=Post::model()-&amp;gt;exists($condition,$params);

// 2. 使用 `CDbCriteria`
$criteria=new CDbCriteria;
$criteria-&amp;gt;select=&#39;title&#39;;  // 只选择 &#39;title&#39; 列
$criteria-&amp;gt;condition=&#39;postID=:postID&#39;;
$criteria-&amp;gt;params=array(&#39;:postID&#39;=&amp;gt;10);
$post=Post::model()-&amp;gt;find($criteria); // $params 不需要了

// 3. 传递数组
$post=Post::model()-&amp;gt;find(array(
    &#39;select&#39;=&amp;gt;&#39;title&#39;,
    &#39;condition&#39;=&amp;gt;&#39;postID=:postID&#39;,
    &#39;params&#39;=&amp;gt;array(&#39;:postID&#39;=&amp;gt;10),
));
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新记录:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果一个 AR 实例是使用 new 操作符创建的, 调用 &lt;code&gt;CActiveRecord::save&lt;/code&gt; 将会向数据表中插入一行新数据; 如果 AR 实例是某个 find 或 findAll 方法的结果, 调用 &lt;code&gt;CActiveRecord::save&lt;/code&gt; 将更新表中现有的行. 实际上, 我们是使用 &lt;code&gt;CActiveRecord::isNewRecord&lt;/code&gt; 说明一个 AR 实例是不是新的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直接更新数据表中的一行或多行而不首先载入也是可行的:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 更新符合指定条件的行
Post::model()-&amp;gt;updateAll($attributes,$condition,$params);
// 更新符合指定条件和主键的行
Post::model()-&amp;gt;updateByPk($pk,$attributes,$condition,$params);
// 更新满足指定条件的行的计数列
Post::model()-&amp;gt;updateCounters($counters,$condition,$params);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除记录:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实例化后删除: 这样删除之后, AR 实例仍不改变&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$post=Post::model()-&amp;gt;findByPk(10); // 假设有一个帖子，其 ID 为 10
$post-&amp;gt;delete(); // 从数据表中删除此行
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;不实例化直接删除&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 删除符合指定条件的行
Post::model()-&amp;gt;deleteAll($condition,$params);
// 删除符合指定条件和主键的行
Post::model()-&amp;gt;deleteByPk($pk,$condition,$params);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要确定两个 AR 是否是同一个记录, 只需对比它们的主键值, 或直接调用 &lt;code&gt;CActiveRecord::equals()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过以下几个占位符方法, 可以自定义 AR 的工作流:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;占位符方法&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeValidate, afterValidate&lt;/td&gt;
      &lt;td&gt;在验证之前(后)执行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeSave, afterSave&lt;/td&gt;
      &lt;td&gt;在保存 AR 实例之前(后)执行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeFind, afterFind&lt;/td&gt;
      &lt;td&gt;在执行查询之前(后)执行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;afterConstruct&lt;/td&gt;
      &lt;td&gt;在 AR 实例化之后执行&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;数据验证和块赋值参见&lt;a href=&quot;#triggerValidation&quot;&gt;触发验证&lt;/a&gt;和&lt;a href=&quot;#massiveAssign&quot;&gt;块赋值&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;事务处理, 参见&lt;a href=&quot;#&quot;&gt;使用事务&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$model=Post::model();
$transaction=$model-&amp;gt;dbConnection-&amp;gt;beginTransaction();
try {
    // 查找和保存是可能由另一个请求干预的两个步骤
    // 这样我们使用一个事务以确保其一致性和完整性
    $post=$model-&amp;gt;findByPk(10);
    $post-&amp;gt;title=&#39;new post title&#39;;
    $post-&amp;gt;save();
    $transaction-&amp;gt;commit();
} catch(Exception $e) {
    $transaction-&amp;gt;rollBack();
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名范围: 即查询时的过滤器&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
class Post extends CActiveRecord {
    /**
     * 默认命名范围, 隐式应用于所有关于此模型的 SELECT 查询
     */
    public function defaultScope() {
        return array(
            &#39;condition&#39;=&amp;gt;&quot;language=&#39;&quot;.Yii::app()-&amp;gt;language.&quot;&#39;&quot;,
        );
    }

    /**
     * 这里定义的命名范围可以被显式应用于 SELECT,UPDATE,CREATE,DELETE 操作
     * @return {[type]} [description]
     */
    public function scopes() {
        return array(
            &#39;published&#39;=&amp;gt;array(
                &#39;condition&#39;=&amp;gt;&#39;status=1&#39;,
            ),
            &#39;recently&#39;=&amp;gt;array(
                &#39;order&#39;=&amp;gt;&#39;create_time DESC&#39;,
                &#39;limit&#39;=&amp;gt;5,
            ),
        );
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$posts=Post::model()-&amp;gt;published()-&amp;gt;recently()-&amp;gt;findAll();
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##关系型 Active Record&lt;/p&gt;

&lt;p&gt;为了使用关系型 AR, 建议在关联的表中定义主键-外键约束&lt;/p&gt;

&lt;p&gt;关系包括: &lt;code&gt;BELONGS_TO&lt;/code&gt;, &lt;code&gt;HAS_MANY&lt;/code&gt;, &lt;code&gt;HAS_ONE&lt;/code&gt;, &lt;code&gt;MANY_MANY&lt;/code&gt;, &lt;code&gt;STAT&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;STAT&lt;/code&gt; 关系已获取统计数据&lt;/p&gt;

&lt;p&gt;适当使用 &lt;code&gt;together&lt;/code&gt; 查询选项, 会加快查询速度&lt;/p&gt;

&lt;p&gt;在 AR 查询中, 基础表的别名为 &lt;code&gt;t&lt;/code&gt;, 其他关联表的别名和关系的名称一样&lt;/p&gt;

&lt;p&gt;声明关系&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
class Post extends CActiveRecord {
    public function relations() {
        return array(
            &#39;author&#39;=&amp;gt;array(self::BELONGS_TO, &#39;User&#39;, &#39;author_id&#39;),
            &#39;categories&#39;=&amp;gt;array(self::MANY_MANY, &#39;Category&#39;,
                &#39;tbl_post_category(post_id, category_id)&#39;),
        );
    }
}

class User extends CActiveRecord {
    public function relations() {
        return array(
            &#39;posts&#39;=&amp;gt;array(self::HAS_MANY, &#39;Post&#39;, &#39;author_id&#39;),
            &#39;profile&#39;=&amp;gt;array(self::HAS_ONE, &#39;Profile&#39;, &#39;owner_id&#39;),
        );
    }
}

// 使用额外的选项
// 可用选项包括: select, condition, params, on, order, with, joinType, alias, together, join, group, having, index
// 当使用 `STAT` 关系时, 可用的选项包括: select, defaultValue, condition, params, order, group, having
class User extends CActiveRecord {
    public function relations() {
        return array(
            &#39;posts&#39;=&amp;gt;array(self::HAS_MANY, &#39;Post&#39;, &#39;author_id&#39;,
                            &#39;order&#39;=&amp;gt;&#39;posts.create_time DESC&#39;,
                            &#39;with&#39;=&amp;gt;&#39;categories&#39;),
            &#39;profile&#39;=&amp;gt;array(self::HAS_ONE, &#39;Profile&#39;, &#39;owner_id&#39;),
        );
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行关联查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 1. 懒惰式加载: 
// 获取 ID 为 10 的帖子
$post=Post::model()-&amp;gt;findByPk(10);
// 获取帖子的作者(author): 此处将执行一个关联查询。
$author=$post-&amp;gt;author;

// 2. 渴求式加载(比懒惰式高效)
// 2.1 常规方式
// 获取 post 及其作者和分类
$posts=Post::model()-&amp;gt;with(&#39;author&#39;)-&amp;gt;findAll();
// 获取 post 及其作者和分类, 以及作者简介(author.profile) 和帖子(author.posts)
$posts=Post::model()-&amp;gt;with(
    &#39;author.profile&#39;,
    &#39;author.posts&#39;,
    &#39;categories&#39;)-&amp;gt;findAll();
// 2.2 指定 `CDbCeteria::with` 属性
$criteria=new CDbCriteria;
$criteria-&amp;gt;with=array(
    &#39;author.profile&#39;,
    &#39;author.posts&#39;,
    &#39;categories&#39;,
);
$posts=Post::model()-&amp;gt;findAll($criteria);
// 2.3 配置数组
$posts=Post::model()-&amp;gt;findAll(array(
    &#39;with&#39;=&amp;gt;array(
        &#39;author.profile&#39;,
        &#39;author.posts&#39;,
        &#39;categories&#39;,
    )
);

// 3. 动态
// 3.1
User::model()-&amp;gt;with(array(
    &#39;posts&#39;=&amp;gt;array(&#39;order&#39;=&amp;gt;&#39;posts.create_time ASC&#39;),
    &#39;profile&#39;,
))-&amp;gt;findAll();
// 3.2
$user=User::model()-&amp;gt;findByPk(1);
$posts=$user-&amp;gt;posts(array(&#39;condition&#39;=&amp;gt;&#39;status=1&#39;));

// 如果关系中没有相关的实例，则相应的属性将为 null(BELONGS_TO, HAS_ONE) 或一个空数组(HAS_MANY, MANY_MANY)
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 1.
class User extends CActiveRecord {
    public function relations() {
        return array(
            &#39;posts&#39;=&amp;gt;array(self::HAS_MANY, &#39;Post&#39;, &#39;author_id&#39;,
                &#39;with&#39;=&amp;gt;&#39;comments:approved&#39;),
        );
    }
}
// 2.
$posts=Post::model()-&amp;gt;published()-&amp;gt;recently()-&amp;gt;with(&#39;comments&#39;)-&amp;gt;findAll();
// 3.
$posts=Post::model()-&amp;gt;published()-&amp;gt;recently()-&amp;gt;with(&#39;comments&#39;)-&amp;gt;findAll();
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##数据库迁移 @todo&lt;/p&gt;

&lt;p&gt;#缓存&lt;/p&gt;

&lt;p&gt;##配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
array(
    ......
    &#39;components&#39;=&amp;gt;array(
        ......
        &#39;cache&#39;=&amp;gt;array(
            // 支持的缓存包括:
            // - CMemCache
            // - CXCache
            // - CEAcceleratorCache
            // - CDbCache: 默认使用 runtime 目录下的 SQLite3 数据库
            // - CZendDataCache
            // - CFileCache
            // - CDummyCache: 只是为了开发阶段模拟尚未实现的缓存功能
            &#39;class&#39;=&amp;gt;&#39;system.caching.CMemCache&#39;,
            &#39;servers&#39;=&amp;gt;array(
                array(&#39;host&#39;=&amp;gt;&#39;server1&#39;, &#39;port&#39;=&amp;gt;11211, &#39;weight&#39;=&amp;gt;60),
                array(&#39;host&#39;=&amp;gt;&#39;server2&#39;, &#39;port&#39;=&amp;gt;11211, &#39;weight&#39;=&amp;gt;40),
            ),
        ),
    ),
);
 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##数据缓存(用于存储变量)&lt;/p&gt;

&lt;p&gt;###存取操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
// 生成
// 过期时间 30 可选, 同一个应用中的缓存 id 必须唯一
Yii::app()-&amp;gt;cache-&amp;gt;set($id, $value, 30); 

// 调取
// 1. 单个
$value=Yii::app()-&amp;gt;cache-&amp;gt;get($id);
if ($value === false)
{
    // 因为在缓存中没找到 $value ，重新生成它 ，
    // 并将它存入缓存以备以后使用：
    // Yii::app()-&amp;gt;cache-&amp;gt;set($id,$value);
}
// 2. 批量
$values=Yii::app()-&amp;gt;cache-&amp;gt;mget(array $ids);

// 删除
Yii::app()-&amp;gt;cache-&amp;gt;delete($id);

// 重刷
Yii::app()-&amp;gt;cache-&amp;gt;flush();

// CCache 实现了 ArrayAccess, 所以也可通过下列方式操作:
$cache=Yii::app()-&amp;gt;cache;
$cache[&#39;var1&#39;]=$value1;  // 相当于: $cache-&amp;gt;set(&#39;var1&#39;,$value1);
$value2=$cache[&#39;var2&#39;];  // 相当于: $value2=$cache-&amp;gt;get(&#39;var2&#39;);
 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###缓存依赖&lt;/p&gt;

&lt;p&gt;除了过期设置，缓存数据也可能会因为依赖条件发生变化而失效。例如，如果我们缓存了某些文件的内容，而这些文件发生了改变，我们就应该让缓存的数据失效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
// 此值将在30秒后失效
// 也可能因依赖的文件发生了变化而更快失效
Yii::app()-&amp;gt;cache-&amp;gt;set($id, $value, 30, new CFileCacheDependency(&#39;FileName&#39;));
// 可用的依赖有:
// - CFileCacheDependency: 如果文件的最后修改时间发生改变
// - CDirectoryCacheDependency: 如果目录和其子目录中的文件发生改变
// - CDbCacheDependency: 如果指定 SQL 语句的查询结果发生改变
// - CGlobalStateCacheDependency: 如果指定的全局状态发生改变
// - CChainedCacheDependency: 如果链中的任何依赖发生改变
// - CExpressionDependency: 如果指定的 PHP 表达式的结果发生改变
 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##片段缓存&lt;/p&gt;

&lt;p&gt;###基本使用方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php if($this-&amp;gt;beginCache($id)) { // 如果缓存有效, 则输出缓存... ?&amp;gt;
    ...被缓存的内容...
&amp;lt;?php $this-&amp;gt;endCache(); } // ...否则在此处存储缓存 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###使用缓存选项&lt;/p&gt;

&lt;p&gt;&lt;code&gt;beginCache()&lt;/code&gt; 和 &lt;code&gt;endCache()&lt;/code&gt; 方法是 &lt;code&gt;COutputCache&lt;/code&gt; widget 的包装, 因此 &lt;code&gt;COutputCache&lt;/code&gt; 的所有属性都可以在缓存选项中初始化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php if($this-&amp;gt;beginCache(
            $id, 
            array(
                // 过期时间, 默认 60
                &#39;duration&#39; =&amp;gt; 3600,
                // 依赖, 可以是一个实现 `ICacheDependency` 的对象, 
                // 或能生成依赖对象想的配置数组
                // 参见数据缓存
                &#39;dependency&#39; =&amp;gt; array(
                    &#39;class&#39;=&amp;gt;&#39;system.caching.dependencies.CDbCacheDependency&#39;,
                    &#39;sql&#39;=&amp;gt;&#39;SELECT MAX(lastModified) FROM Post&#39;
                ),
                // 变化, 指定缓存将根据哪些因素变化
                // 其他可用的有: `varyByRoute`, `varyBySession`, `varyByParam`, `varyByLanguage`
                &#39;varyByExpression&#39; =&amp;gt; &#39;Yii::app()-&amp;gt;user-&amp;gt;isGuest&#39;,
                // 请求类型: 只对指定的请求类型启用缓存
                &#39;requestTypes&#39; =&amp;gt; array(&#39;GET&#39;)
                )
            )
        ) { ?&amp;gt;
        ...被缓存的内容...
&amp;lt;?php $this-&amp;gt;endCache(); } ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###嵌套&lt;/p&gt;

&lt;p&gt;片段缓存可以嵌套, 当数据存储在外部缓存无效, 内部缓存仍然可以提供有效的内部片段. 然而反之就不行了&lt;/p&gt;

&lt;p&gt;##页面缓存&lt;/p&gt;

&lt;p&gt;如果想要缓存整个页面, 我们应该跳过产生网页内容的动作执行. 我们可以使用 &lt;code&gt;COutputCache&lt;/code&gt; 或 &lt;code&gt;CHttpCacheFilter&lt;/code&gt; 作为动作过滤器来完成这一任务&lt;/p&gt;

&lt;p&gt;###COutputCache&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
public function filters()
{
    return array(
        array(
            &#39;COutputCache&#39;,
            &#39;duration&#39;=&amp;gt;100,
            &#39;varyByParam&#39;=&amp;gt;array(&#39;id&#39;),
        ),
    );
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###CHttpCacheFilter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
public function filters()
{
    return array(
        array(
            &#39;CHttpCacheFilter + index&#39;,
            &#39;lastModified&#39;=&amp;gt;Yii::app()-&amp;gt;db-&amp;gt;createCommand(&quot;SELECT MAX(`update_time`) FROM &quot;)-&amp;gt;queryScalar(),
        ),
    );
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##动态内容&lt;/p&gt;

&lt;p&gt;动态内容是指, 即使是在片段缓存包括的内容中也不会被缓存, 而是通过传递给 &lt;code&gt;renderDynamic&lt;/code&gt; 的有效回调函数生成&lt;/p&gt;

&lt;p&gt;回调可以是指向当前控制器类的方法或者全局函数的字符串名, 
也可以是一个数组名指向一个类的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php if($this-&amp;gt;beginCache($id)) { ?&amp;gt;
...被缓存的片段内容...
    &amp;lt;?php $this-&amp;gt;renderDynamic($callback); ?&amp;gt;
...被缓存的片段内容...
&amp;lt;?php $this-&amp;gt;endCache(); } ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#专题&lt;/p&gt;

&lt;p&gt;##URL 管理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置 URL 格式及转发规则:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: 过多的规则会导致应用性能下降&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
// 在配置文件中:
array(
    &#39;components&#39;=&amp;gt;array(
        &#39;urlManager&#39;=&amp;gt;array(
            &#39;urlFormat&#39;=&amp;gt;&#39;path&#39;, // 格式
            &#39;rules&#39;=&amp;gt;array(      // 转发规则
                // 1.
                // `pattern` 用于和当前 URL 的 path info 做匹配
                // 匹配成功的话, 会跳转到对应的 `route` 指定的 CA
                &#39;pattern1&#39;=&amp;gt;&#39;route1&#39;,

                // 2.
                // 也可以使用数组形式指定转发规则, 如此一来便能针对同一 pattern  指定多个规则, 或者通过 verb 来支持 RESTful URL
                array(
                    &#39;route1&#39;, 
                    &#39;pattern&#39;=&amp;gt;&#39;pattern1&#39;, 
                    &#39;urlSuffix&#39;=&amp;gt;&#39;.xml&#39;, 
                    &#39;caseSensitive&#39;=&amp;gt;false
                ),
                // 可用的选项包括: `pattern`, `urlSuffix`, `caseSensitive`, `defualtParams`, `matchValue`, `verb`, `parsisngOnly`

                // 3.
                // 使用命名参数: &amp;lt;ParamName:ParamPattern&amp;gt;
                // 当 URL 被解析后, 命名的参数会自动生成到 $_GET 中
                &#39;http://&amp;lt;user:\w+&amp;gt;.example.com/&amp;lt;lang:\w+&amp;gt;/profile&#39; =&amp;gt; &#39;user/profile&#39;,

                // 示例:
                array(
                    &#39;api/&amp;lt;controller&amp;gt;/update&#39;, 
                    &#39;pattern&#39;=&amp;gt;&#39;api/&amp;lt;controller:\w+&amp;gt;/&amp;lt;id:\d+&amp;gt;&#39;, 
                    &#39;verb&#39;=&amp;gt;&#39;PUT, POST&#39;
                ),
                array(
                    &#39;api/&amp;lt;controller&amp;gt;/delete&#39;, 
                    &#39;pattern&#39;=&amp;gt;&#39;api/&amp;lt;controller:\w+&amp;gt;/&amp;lt;id:\d+&amp;gt;&#39;, 
                    &#39;verb&#39;=&amp;gt;&#39;DELETE&#39;
                ),
                &#39;&amp;lt;controller:\w+&amp;gt;/&amp;lt;action:\w+&amp;gt;/&amp;lt;id:\d+&amp;gt;&#39;=&amp;gt;&#39;&amp;lt;controller&amp;gt;/&amp;lt;action&amp;gt;&#39;,
                &#39;&amp;lt;action:(login|logout|about)&amp;gt;&#39; =&amp;gt; &#39;site/&amp;lt;action&amp;gt;&#39;,
            ),
        ),
    ),
);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生成 URL:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
// createUrl 生成相对 URL
$this-&amp;gt;createUrl(&#39;post/read&#39;, array(&#39;id&#39; =&amp;gt; 100));
// 如果要得到绝对 URL, 可以使用 `Yii::app()-&amp;gt;hostInfo;` 或 `CController::createAbsosluteUrl`
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用自定义 URL 解析器:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义解析器类&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
/**
 * 自定义 URL 解析器必须继承 CBasUrlRule, 并实现 `createUrl()` 和 `parseUrl`
 */
class CarUrlRule extends CBaseUrlRule
{
    public $connectionID = &#39;db&#39;;
 
    public function createUrl($manager,$route,$params,$ampersand)
    {
        if ($route===&#39;car/index&#39;)
        {
            if (isset($params[&#39;manufacturer&#39;], $params[&#39;model&#39;]))
                return $params[&#39;manufacturer&#39;] . &#39;/&#39; . $params[&#39;model&#39;];
            else if (isset($params[&#39;manufacturer&#39;]))
                return $params[&#39;manufacturer&#39;];
        }
        return false;  // this rule does not apply
    }
 
    public function parseUrl($manager,$request,$pathInfo,$rawPathInfo)
    {
        if (preg_match(&#39;%^(\w+)(/(\w+))?$%&#39;, $pathInfo, $matches))
        {
            // check $matches[1] and $matches[3] to see
            // if they match a manufacturer and a model in the database
            // If so, set $_GET[&#39;manufacturer&#39;] and/or $_GET[&#39;model&#39;]
            // and return &#39;car/index&#39;
        }
        return false;  // this rule does not apply
    }
}


?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;指定 URL 转发规则:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php 
array(
        &#39;class&#39; =&amp;gt; &#39;application.components.CarUrlRule&#39;,
        &#39;connectionID&#39; =&amp;gt; &#39;db&#39;,
    ), 
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##验证&lt;/p&gt;

&lt;p&gt;验证即核查一个人是否真实他声称的那个人(用户名, 密码); 授权即检查是否有权操作特定的资源&lt;/p&gt;

&lt;p&gt;定义身份类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
class UserIdentity extends CUserIdentity {
    private $_id;

    /**
     * 这是身份类的主要工作, 实现验证
     */
    public function authenticate() {
        // 使用 User AR 获取数据
        $record=User::model()-&amp;gt;findByAttributes(array(&#39;username&#39;=&amp;gt;$this-&amp;gt;username));
        if($record===null) {
            $this-&amp;gt;errorCode=self::ERROR_USERNAME_INVALID;
        } else if {
            ($record-&amp;gt;password!==md5($this-&amp;gt;password))
            $this-&amp;gt;errorCode=self::ERROR_PASSWORD_INVALID;
        } else {
            $this-&amp;gt;_id=$record-&amp;gt;id;
            // 使用 setState 把 title 信息存储为状态传递给 CWebUser
            // 之后便可以使用 Yii::app()-&amp;gt;user-&amp;gt;title 访问
            // CWebUser 默认会存储状态信息到 session, 但如果 CWebUser::allowAutoLogin 为 true, 则会存到 cookie, 切勿将敏感信息存入 cookie
            $this-&amp;gt;setState(&#39;title&#39;, $record-&amp;gt;title);
            $this-&amp;gt;errorCode=self::ERROR_NONE;
        }
        return !$this-&amp;gt;errorCode;
    }

    /**
     * 重写 getId, 默认的实现是直接返回用户名
     */
    public function getId() {
        return $this-&amp;gt;_id;
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登录和注销:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 1. 使用提供的用户名和密码登录用户
$identity=new UserIdentity($username,$password);
if($identity-&amp;gt;authenticate()) {
    // 将用户身份信息存入持久存储(默认为 Session)
    // 之后便可以用 `Yii::app-&amp;gt;user-&amp;gt;isGuest` 判断用户是否登录
    Yii::app()-&amp;gt;user-&amp;gt;login($identity);
} else {
    echo $identity-&amp;gt;errorMessage;
}
......

// 注销当前用户
Yii::app()-&amp;gt;user-&amp;gt;logout();

// 2. 使用 Cookie 登录
// 要确保用户部件的allowAutoLogin被设置为true。
// 保留用户登陆状态时间7天
Yii::app()-&amp;gt;user-&amp;gt;login($identity,3600*24*7);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用 cookie 登录, 要确保不要保存敏感信息到 State, 而是保存到持久存储(数据库) 上, 最好(参见&lt;a href=&quot;#security&quot;&gt;安全&lt;/a&gt;):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当用户成功登录时, 保存同一个随机串到 cookie State 和数据库&lt;/li&gt;
  &lt;li&gt;在之后的的自动 cookie 登录时, 对比 cookie 中和数据库中的随机串是否一致&lt;/li&gt;
  &lt;li&gt;如果用户通过登录表单登录, 刷新这个随机串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##授权&lt;/p&gt;

&lt;p&gt;访问控制过滤器的定义参见&lt;a href=&quot;#filter&quot;&gt;过滤器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;过滤器定义之后, 还要通过重载 &lt;code&gt;CController::accessRules&lt;/code&gt; 指定具体授权规则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
class PostController extends CController {
    /**
     * 配置数组的值可为
     * 第一项: `deny` 或者 `allow`
     * actions: action 名字
     * users: *: 任何用户, ?: 匿名用户, @: 验证通过的用户 
     */
    public function accessRules() {
        return array(
            array(&#39;deny&#39;,
                &#39;actions&#39;=&amp;gt;array(&#39;create&#39;, &#39;edit&#39;),
                &#39;users&#39;=&amp;gt;array(&#39;?&#39;),
            ),
            array(&#39;allow&#39;,
                &#39;actions&#39;=&amp;gt;array(&#39;delete&#39;),
                &#39;roles&#39;=&amp;gt;array(&#39;admin&#39;),
            ),
            array(&#39;deny&#39;,
                &#39;actions&#39;=&amp;gt;array(&#39;delete&#39;),
                &#39;users&#39;=&amp;gt;array(&#39;*&#39;),
            ),
            // 为了确保某类动作在没允许情况下不被执行
            array(&#39;deny&#39;,
                    &#39;action&#39;=&amp;gt;&#39;delete&#39;,
            )
        );
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果授权失败&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;已经配置 &lt;code&gt;CWebUser::loingUrl&lt;/code&gt;, 则重定向到此 URL, 可以这样配置:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  array(
      ......
      &#39;components&#39;=&amp;gt;array(
          &#39;user&#39;=&amp;gt;array(
              // 这实际上是默认值
              &#39;loginUrl&#39;=&amp;gt;array(&#39;site/login&#39;),
          ),
      ),
  )
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;否则显示一个 401 HTTP 例外&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果希望在用户登录成功后转到之前页面:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
Yii::app()-&amp;gt;request-&amp;gt;redirect(Yii::app()-&amp;gt;user-&amp;gt;returnUrl);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##基于角色的访问控制(Role-Based Access Control)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;授权项目&lt;/code&gt;可分为&lt;code&gt;操作(operations)&lt;/code&gt;, &lt;code&gt;任务(tasks)&lt;/code&gt; 和&lt;code&gt;角色(roles)&lt;/code&gt; 一个角色由若干任务组成, 一个任务由若干操作组成， 而一个操作就是一个&lt;code&gt;许可&lt;/code&gt;, 不可再分. Yii 还允许一个角色包含其他角色或操作, 一个任务可以包含其他操作, 一个操作可以包括其他操作. 授权项目是通过它的名字唯一识别的&lt;/p&gt;

&lt;p&gt;一个授权项目可能与一个&lt;code&gt;业务规则&lt;/code&gt;关联. 业务规则是一段 PHP 代码, 在进行涉及授权项目的访问检查时将会被执行. 仅在执行返回 &lt;code&gt;true&lt;/code&gt; 时, 用户才会被视为拥有此授权项目所代表的权限许可&lt;/p&gt;

&lt;p&gt;Yii 提供了两种授权管理器： &lt;code&gt;CPhpAuthManager&lt;/code&gt; 和 &lt;code&gt;CDbAuthManager&lt;/code&gt;. 前者将授权数据存储在一个 PHP 脚本文件中而后者存储在数据库中.  配置 &lt;code&gt;CWebApplication::authManager&lt;/code&gt; 应用组件时, 我们需要指定使用哪个授权管理器组件类, 以及所选授权管理器组件的初始化属性值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
return array(
    &#39;components&#39;=&amp;gt;array(
        &#39;db&#39;=&amp;gt;array(
            &#39;class&#39;=&amp;gt;&#39;CDbConnection&#39;,
            &#39;connectionString&#39;=&amp;gt;&#39;sqlite:path/to/file.db&#39;,
        ),
        &#39;authManager&#39;=&amp;gt;array(
            &#39;class&#39;=&amp;gt;&#39;CDbAuthManager&#39;,
            &#39;connectionID&#39;=&amp;gt;&#39;db&#39;,
        ),
    ),
);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后, 我们便可以使用 &lt;code&gt;Yii::app()-&amp;gt;authManager&lt;/code&gt; 访问&lt;/p&gt;

&lt;p&gt;定义授权等级体总共分三步&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义授权项目
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;CAuthManager::createRole&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;CAuthManager::createTask&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;CAuthManager::createOperation&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;建立授权项目之间的关系
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;CAuthManager::addItemChild&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;CAuthManager::removeItemChild&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;CAuthItem::addChild&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;CAuthItem::removeChild&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分配角色给用户
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;CAuthManager::assign&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;CAuthManager::revoke&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
// 并不需要在每个请求中都要运行
$auth=Yii::app()-&amp;gt;authManager;

$auth-&amp;gt;createOperation(&#39;createPost&#39;,&#39;create a post&#39;);
$auth-&amp;gt;createOperation(&#39;readPost&#39;,&#39;read a post&#39;);
$auth-&amp;gt;createOperation(&#39;updatePost&#39;,&#39;update a post&#39;);
$auth-&amp;gt;createOperation(&#39;deletePost&#39;,&#39;delete a post&#39;);

$bizRule=&#39;return Yii::app()-&amp;gt;user-&amp;gt;id==$params[&quot;post&quot;]-&amp;gt;authID;&#39;;
$task=$auth-&amp;gt;createTask(&#39;updateOwnPost&#39;,&#39;update a post by author himself&#39;,$bizRule);
$task-&amp;gt;addChild(&#39;updatePost&#39;);

$role=$auth-&amp;gt;createRole(&#39;reader&#39;);
$role-&amp;gt;addChild(&#39;readPost&#39;);

$role=$auth-&amp;gt;createRole(&#39;author&#39;);
$role-&amp;gt;addChild(&#39;reader&#39;);
$role-&amp;gt;addChild(&#39;createPost&#39;);
$role-&amp;gt;addChild(&#39;updateOwnPost&#39;);

$role=$auth-&amp;gt;createRole(&#39;editor&#39;);
$role-&amp;gt;addChild(&#39;reader&#39;);
$role-&amp;gt;addChild(&#39;updatePost&#39;);

$role=$auth-&amp;gt;createRole(&#39;admin&#39;);
$role-&amp;gt;addChild(&#39;editor&#39;);
$role-&amp;gt;addChild(&#39;author&#39;);
$role-&amp;gt;addChild(&#39;deletePost&#39;);

$auth-&amp;gt;assign(&#39;reader&#39;,&#39;readerA&#39;);
$auth-&amp;gt;assign(&#39;author&#39;,&#39;authorB&#39;);
$auth-&amp;gt;assign(&#39;editor&#39;,&#39;editorC&#39;);
$auth-&amp;gt;assign(&#39;admin&#39;,&#39;adminD&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;权限检查:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
if(Yii::app()-&amp;gt;user-&amp;gt;checkAccess(&#39;createPost&#39;)) {
    // 创建帖子
}

// 也可传参
$params=array(&#39;post&#39;=&amp;gt;$post);
if(Yii::app()-&amp;gt;user-&amp;gt;checkAccess(&#39;updateOwnPost&#39;,$params)) {
    // 更新帖子
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认角色就是一个隐式分配给每个用户的角色, 这些用户包括通过身份验证的用户和游客&lt;/p&gt;

&lt;p&gt;配置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
return array(
    &#39;components&#39;=&amp;gt;array(
        &#39;authManager&#39;=&amp;gt;array(
            &#39;class&#39;=&amp;gt;&#39;CDbAuthManager&#39;,
            &#39;defaultRoles&#39;=&amp;gt;array(&#39;authenticated&#39;, &#39;guest&#39;),
        ),
    ),
);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$bizRule=&#39;return !Yii::app()-&amp;gt;user-&amp;gt;isGuest;&#39;;
$auth-&amp;gt;createRole(&#39;authenticated&#39;, &#39;authenticated user&#39;, $bizRule);

$bizRule=&#39;return Yii::app()-&amp;gt;user-&amp;gt;isGuest;&#39;;
$auth-&amp;gt;createRole(&#39;guest&#39;, &#39;guest user&#39;, $bizRule);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##安全&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;XSS: 跨站脚本攻击&lt;/p&gt;

    &lt;p&gt;定义: 攻击者常常向易受攻击的 web 应用注入 JavaScript, VBScript, ActiveX, HTML 或 Flash 来迷惑访问者以收集访问者的信息&lt;/p&gt;

    &lt;p&gt;防范: 在显示用户输入的内容之前进行检查&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  // 这里将 CHtmlPurifier 作为一个 Widget 来过滤用户输入
  &amp;lt;?php $this-&amp;gt;beginWidget(&#39;CHtmlPurifier&#39;); ?&amp;gt;
  //...这里显示用户输入的内容...
  &amp;lt;?php $this-&amp;gt;endWidget(); ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CSRF: 跨站请求伪造&lt;/p&gt;

    &lt;p&gt;定义: 攻击者在用户浏览器在访问恶意网站的时候, 让用户的浏览器向一个受信任的网站发起攻击者指定的请求&lt;/p&gt;

    &lt;p&gt;防范: GET 请求只允许检索数据而不能修改服务器上的任何数据, 而 POST 请求应当含有一些可以被服务器识别的随机数值, 用来保证表单数据的来源和运行结果发送的去向是相同的&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;php
  &amp;lt;?php
  // 启用 CsrfValidation 组件
  // 该组件会自动在用 CHtml::form 生成的表单中嵌入一个保存随机值的隐藏项, 在表单提交的时候发送到服务器进行验证
  return array(
      &#39;components&#39;=&amp;gt;array(
          &#39;request&#39;=&amp;gt;array(
              &#39;enableCsrfValidation&#39;=&amp;gt;true,
          ),
      ),
  );
  ?&amp;gt;
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cookie 攻击&lt;/p&gt;

    &lt;p&gt;定义: session ID 通常存储在  Cookie中, 如果攻击者窃取到了一个有效的 session ID, 他就可以使用这个 session ID 对应的 session 信息&lt;/p&gt;

    &lt;p&gt;防范:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;您可以使用 SSL 来产生一个安全通道, 且只通过 HTTPS 连接来传送验证 cookie&lt;/li&gt;
      &lt;li&gt;设置 cookie 的过期时间, 对所有的 cookie 和 session 令牌也这样做&lt;/li&gt;
      &lt;li&gt;防范跨站代码攻击, 因为它可以在用户的浏览器触发任意代码, 这些代码可能会泄露用户的 cookie&lt;/li&gt;
      &lt;li&gt;在 cookie 有变动的时候验证 cookie 的内容&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```php
  &amp;lt;?php
  // 1. 启用 CookieValidation 组件 
  return array(
      ‘components’=&amp;gt;array(
          ‘request’=&amp;gt;array(
              ‘enableCookieValidation’=&amp;gt;true,
          ),
      ),
  );&lt;/p&gt;

    &lt;p&gt;// 然后只使用 CHttpRequest::cookies 进行 cookie 操作(而不是 $_COOKIES)
  // 检索一个名为$name的cookie值
  $cookie=Yii::app()-&amp;gt;request-&amp;gt;cookies[$name];
  $value=$cookie-&amp;gt;value;
  ……
  // 设置一个cookie
  $cookie=new CHttpCookie($name,$value);
  Yii::app()-&amp;gt;request-&amp;gt;cookies[$name]=$cookie;
  ?&amp;gt;
  ```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 19 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://panke.me//notes/learning-note-YII(1.1)</link>
        <guid isPermaLink="true">http://panke.me//notes/learning-note-YII(1.1)</guid>
        
        <category>php</category>
        
        <category>framework</category>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>理解 diff 命令</title>
        <description>&lt;p&gt;&lt;em&gt;原文在 2009/04/17 发表于 &lt;a href=&quot;http://unix.worldiswelcome.com/understanding-the-diff-command-in-unix&quot;&gt;http://unix.worldiswelcome.com/understanding-the-diff-command-in-unix&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Unix 系统管理员来经常需要去知道两个文件之间有什么差异. &lt;code&gt;diff&lt;/code&gt; 命令就是干这个的. 我现在就准备讲讲 &lt;code&gt;diff&lt;/code&gt;. 它是一个经常被用到却不是很被了解的命令. 我希望 Unix 使用者在读完这篇文章之后能够正确了解这个命令的用途并从中获益. 另外一个有用的命令是: &lt;a href=&quot;http://unix.worldiswelcome.com/how-to-find-common-lines-between-two-text-files-in-unix&quot;&gt;&lt;code&gt;comm&lt;/code&gt;&lt;/a&gt; 命令. 我们开始吧…&lt;/p&gt;

&lt;p&gt;示例文件分别是 &lt;em&gt;first&lt;/em&gt; 文件和 &lt;em&gt;second&lt;/em&gt; 文件. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wiw_labs:$ nl first
1 computer
2 modem
3 monitor
4 phone
5 switch

wiw_labs:$ nl second
1 cable
2 mobile
3 screen
4 modem
5 phone
6 server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;diff&lt;/code&gt; 命令用来比较这两个文件之间的差异&lt;/p&gt;

&lt;p&gt;#diff 命令的用法&lt;/p&gt;

&lt;p&gt;我命先从 &lt;code&gt;diff&lt;/code&gt; 的用法说起. &lt;code&gt;diff&lt;/code&gt; 通常这样使用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff first_file second_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条命令意即: first_file 和 second_file 有什么不同&lt;/p&gt;

&lt;p&gt;#diff 命令如何工作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diff&lt;/code&gt; 命令的运作原理就是, 想法设法的让 &lt;em&gt;first&lt;/em&gt; 文件和 &lt;em&gt;second&lt;/em&gt; 文件一样. 它希望通过更改(c), 删除(d) &lt;em&gt;first&lt;/em&gt; 文件中的行以使其和 &lt;em&gt;second&lt;/em&gt; 文件一模一样. 如果需要, 它还会把 &lt;em&gt;second&lt;/em&gt; 文件中的行附加到 &lt;em&gt;first&lt;/em&gt; 文件中. 如果你明白我说的什么, 很好, 如果不明白也随便. 当我使用示例给你解释的时候你就会明白的.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diff&lt;/code&gt; 就是通过下面的这些步骤来生成这两个文件的差异报告的:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;它从 &lt;em&gt;first&lt;/em&gt; 文件和 &lt;em&gt;second&lt;/em&gt; 文件的第 1 行开始. 如果它们不一样, &lt;code&gt;diff&lt;/code&gt; 便顺着 &lt;em&gt;first&lt;/em&gt; 文件往下找, 直到找到和 &lt;em&gt;second&lt;/em&gt; 文件中相似的条目.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果在 &lt;em&gt;first&lt;/em&gt; 文件中没有找到和 &lt;em&gt;second&lt;/em&gt; 文件第 1 行相同的行, 它就再从 &lt;em&gt;second&lt;/em&gt; 文件的第 2 行开始. 它会在 &lt;em&gt;first&lt;/em&gt; 文件中开始找. 然后提议做什么(附加, 更改或删除)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#示例
理论讲得够多了. 我们来点实际例子好解释的更通透一点.
我把这两个文件并排来放, 好理解起来更容易一些. 另外行号也一并显示了出来.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wiw_labs:$ paste first second|nl
1 computer cable
2 modem mobile
3 monitor screen
4 phone modem
5 switch phone
6           server

wiw_labs:$ diff first second
1c1,3
&amp;lt; computer
—
&amp;gt; cable
&amp;gt; mobile
&amp;gt; screen
3d4
&amp;lt; monitor
5c6
&amp;lt; switch
—
&amp;gt; server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在, 看一下上面 &lt;code&gt;paste&lt;/code&gt; 命令带行号的输出. 注意下面几点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;first&lt;/em&gt; 文件的第 2 行(modem) 和 &lt;em&gt;second&lt;/em&gt; 文件的第 4 行(modem) 一致. 所以, 如果我们把 &lt;em&gt;first&lt;/em&gt; 文件中的第 1 行换成 &lt;em&gt;second&lt;/em&gt; 文件中的 1 到 3 行, 这两个文件的第一部分便都一样了. 输出看起来就会是这样的:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;wiw_labs:$ paste first second|nl
1 cable cable
2 mobile mobile
3 screen screen
4 modem modem
5 monitor phone
6 phone server
7 switch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;first&lt;/em&gt; 文件的第 4 行(phone) 和 &lt;em&gt;second&lt;/em&gt; 文件的第 5 行一致. 这意味着如果我们删除 &lt;em&gt;first&lt;/em&gt; 文件中的第 3 行(也就是目前的第 4 行), 这两个文件的第二部分便都一样了.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;wiw_labs:$ paste first second|nl
1 cable cable
2 mobile mobile
3 screen screen
4 modem modem
5 phone phone
6 switch server
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;first&lt;/em&gt; 文件的第 5 行(switch)可用 &lt;em&gt;second&lt;/em&gt; 文件的第 6 行(server)替换. 至此, 这两个文件完全一样了.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;wiw_labs:$ paste first second|nl
1 cable cable
2 mobile mobile
3 screen screen
4 modem modem
5 phone phone
6 server server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在, &lt;code&gt;diff&lt;/code&gt; 命令的输出更容易理解了:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;1c1,3&lt;/strong&gt;: 更改 &lt;em&gt;first&lt;/em&gt; 文件的第一行为 &lt;em&gt;second&lt;/em&gt; 文件的 1 到 3 行&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;3d4&lt;/strong&gt;: 从 &lt;em&gt;first&lt;/em&gt; 文件中删除第 3 行(modem).&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;5c6&lt;/strong&gt;: 更改 &lt;em&gt;first&lt;/em&gt; 文件中的第 5 行(switch) 为 &lt;em&gt;second&lt;/em&gt; 文件中的第 6 行(server)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在, 反过来再看一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wiw_labs:$ paste second first | nl
1 cable computer
2 mobile modem
3 screen monitor
4 modem phone
5 phone switch
6 server

wiw_labs:$ diff second first
1,3c1
&amp;lt; cable
&amp;lt; mobile
&amp;lt; screen
—
&amp;gt; computer
4a3
&amp;gt; monitor
6c5
&amp;lt; server
—
&amp;gt; switch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;我们看到 &lt;em&gt;first&lt;/em&gt; 文件的第 4 行(modem) 和 &lt;em&gt;second&lt;/em&gt; 文件的第 2 行一致. 所以如果我们把 &lt;em&gt;first&lt;/em&gt; 文件的 1 到 3 行替换为 &lt;em&gt;second&lt;/em&gt; 文件的第 1 行, 我们得到如下输出:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;wiw_labs:$ paste second first | nl
1 computer computer
2 modem modem
3 phone monitor
4 server phone
5 switch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;现在, &lt;em&gt;second&lt;/em&gt; 文件的第 3 行(monitor) 在 &lt;em&gt;first&lt;/em&gt; 文件中并不存在. 所以, 把它附加到 &lt;em&gt;first&lt;/em&gt; 文件的第 4 行(modem)后面. 要记住 &lt;code&gt;diff&lt;/code&gt; 命令的输出中的行号永远指的是原始的行号. 现在, 输出看起来是这样的:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;wiw_labs:$ paste second first | nl
1 computer computer
2 modem modem
3 monitor monitor
4 phone phone
5 server switch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;first&lt;/em&gt; 文件的第 6 行(server)需要改成 &lt;em&gt;second&lt;/em&gt; 文件的第 5 行(switch). 更改之后, 两个文件便都一样了:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;1 computer computer
2 modem modem
3 monitor monitor
4 phone phone
5 switch switch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在, 更容易理解 &lt;code&gt;diff&lt;/code&gt; 命令的输出了:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;1,3c1&lt;/strong&gt;: 把 &lt;em&gt;first&lt;/em&gt; 文件的第 1 到 3 行改为 &lt;em&gt;second&lt;/em&gt; 文件的第 1 行.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;4a3&lt;/strong&gt;: 在 &lt;em&gt;first&lt;/em&gt; 文件的第 4 行(modem)后面附加上 &lt;em&gt;second&lt;/em&gt; 文件的第 3 行(monitor).&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;6c5&lt;/strong&gt;: 把 &lt;em&gt;first&lt;/em&gt; 文件的第 6 行(server)改为 &lt;em&gt;second&lt;/em&gt; 文件的第 5 行(switch).&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 28 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://panke.me//translation/Understanding_the_diff_command_in_unix</link>
        <guid isPermaLink="true">http://panke.me//translation/Understanding_the_diff_command_in_unix</guid>
        
        <category>linux</category>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>HTTP 头和 PHP header() 函数</title>
        <description>&lt;p&gt;&lt;em&gt;原文链接: &lt;a href=&quot;http://www.nicholassolutions.com/tutorials/php/headers.html&quot;&gt;http://www.nicholassolutions.com/tutorials/php/headers.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;版权: 本文受 Creative Commons License 版权保护, 你可以在 Creative Commons Attribution NonCommercial NoDerives 2.5 License 下分发该文&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;#引言&lt;/p&gt;

&lt;p&gt;许多初级到中级的的 PHP 程序员把 &lt;a href=&quot;http://www.php.net/manual/function.header.php&quot;&gt;header()&lt;/a&gt; 函数当作某种神秘巫术. 他们可以照着代码示例把功能实现, 但是还是不知道到底它是如果运作的. 我最开始就是这样的.&lt;/p&gt;

&lt;p&gt;实际上它非常简单. 在这篇文章中, 我会解释 HTTP 头(header) 是如何运作的, 它们与 PHP 的关系, 以及它们的 meta 标签 equivalents(对应物)&lt;/p&gt;

&lt;p&gt;希望你读完之后, 能更顺手的使用 header() 函数, 甚至想出一些更多利用它的地方. 我们也会讲到其他一些关于 HTTP 和 PHP 的重要话题. 但是在我们开始讲任何程序相关的东西之前, 我们需要先快速(并且不完整的)过一遍 HTTP (HyperTex Transfer Protocol) 运作原理&lt;/p&gt;

&lt;p&gt;#HTTP 概览&lt;/p&gt;

&lt;p&gt;##Headers: 对话中的词语&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/HyperText_Transfer_Protocol&quot;&gt;HTTP&lt;/a&gt; 是 web 服务器和客户端浏览器之间的数据传输(比如 web 页面中的 HTML, 图片, 文件)协议(‘规则’集合), 并且通常使用 80 &lt;a href=&quot;http://en.wikipedia.org/wiki/Port_%28computing%29#Network_port&quot;&gt;端口&lt;/a&gt;. 这就是网站 URL 前面 ‘&lt;code&gt;http://&lt;/code&gt;’ 的来源&lt;/p&gt;

&lt;p&gt;很多人最开始制作 web 页面的时候, 他们先在本地电脑上写 HTML, 在本地浏览器查看是否符合预期, 然后上传到服务器, 就可以在网上浏览这些页面了. 看起来好像在无论在本地查看与在服务器上查看的页面都一样, 传输的数据只有这些 HTML 以及它包含的图片. 但是实际上还有另外一些许多你没看到的信息 - 头信息.&lt;/p&gt;

&lt;p&gt;头信息可以分为两大类: 你浏览器向服务器请求文件时发出的请求头信息, 服务器提供文件给浏览器时发出的响应头信息. 把这些头信息当作浏览器和服务器对话时的词语. 我喜欢把服务器想象为图书管理员, 把浏览器想象成正在请求图书资源的学者. 浏览器走向位于服务台 (80 端口) 的服务器, 说道, “Hi, 我是 Mozilla, 我正在找这个编目号是 ‘www.expertsrt.com’ 的资源. 你可以帮我找到它吗?” 服务器听到后回应 “是的, 我找到了, 让我把它给你. 这里面是 HTML 文本, 它写的是 ‘&lt;code&gt;&amp;lt;html&amp;gt;...&lt;/code&gt;’” 浏览器开始从头到尾的读它, 并且遇到了一个图片标签, 所以向服务器要位于 src 属性指定处的图片. 服务器进行查找, 找到这个文件然后说道 “这是个 PNG 图片, 它的数据是…” 你懂的.&lt;/p&gt;

&lt;p id=&quot;secondConv&quot;&gt;另一个对话可能像这样:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;浏览器: Hi, 我是 Mozilla, 能给我在 ‘www.expertsrt.com/moved.html’ 这里的文件吗?.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;服务器: 那个文件已经不在那儿了, 他现在在 ‘www.expertsrt.com/newloc.html’.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;浏览器: Hi, 我是 Mozilla, 能给我在 ‘www.expertsrt.com/newloc.html’ 这里的文件吗?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;服务器: 我找到这个文件了. 查看它 10 秒钟然后再向我问一次. 它是一个 HTML 文本文件, 它有这些内容…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;…10 秒钟…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;浏览器: Hi, 我是 Mozilla, 能给我在 ‘www.expertsrt.com/newloc.html’ 这里的文件吗?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;服务器: 我找到这个文件了. 查看它 10 秒钟然后再向我问一次. 它是一个 HTML 文本文件, 它有这些内容…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;…10 秒钟…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;浏览器: Hi, 我是 Mozilla, 能给我在 ‘www.expertsrt.com/newloc.html’ 这里的文件吗?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;服务器: 我找到这个文件了. 查看它 10 秒钟然后再向我问一次. 它一个 HTML 文本文件, 它有这些内容…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;…诸如这般, 直到浏览器被用户重新定向…&lt;/p&gt;

&lt;p&gt;正如你所看到的, 使用头信息可以控制许多事情. 使用 header() 函数, 你可以让服务器发送你所需的头信息, 这样你可以做除了发送 HTML 之外许多很酷的事情.&lt;/p&gt;

&lt;p&gt;##看看整个对话过程&lt;/p&gt;

&lt;p&gt;在继续之前, 让我们先不使用浏览器来查看一个 web 页面, 这样我们可以看到整个对话, 更好的了解 HTTP 头的工作. 先打开命令行 (在 windows 中, 点击开始菜单-&amp;gt;运行, 输入 &lt;code&gt;cmd&lt;/code&gt;, 然后点击 “OK”…如果你正使用 linux, 你或许已经知道怎么打开了). 在命令行中输入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;telnet expertsrt.com 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后回车. 这会链接到 expersrt.com 的 80 端口. 然后, 复制并粘贴下面的文字:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1
Host: expertsrt.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你输入或粘贴这些文字的时候, 命令行除了光标的闪烁没看到任何动静的话, 不要担心 – 它们确实被发送到服务器了. 第一行说明你使用 GET 请求方法去获取资源 / (这里是目标主机上基目录里的文件), 并且你在使用 HTTP 1.1 版本. 第二行告诉服务器你想要连接到哪台主机. 当你输入 ‘expertsrt.com’ 后, 回车两次 (只需两次). 你应当立刻得到类似下面的响应:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 301 Moved Permanently
Date: Wed, 08 Feb 2006 07:44:07 GMT
Server: Apache/2.0.54 (Debian GNU/Linux) mod_auth_pgsql/2.0.2b1 mod_ssl/2.0.54 OpenSSL/0.9.7e
Location: http://www.expertsrt.com/
Content-Length: 233
Content-Type: text/html; charset=iso-8859-1

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&amp;gt;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;301 Moved Permanently&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Moved Permanently&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;The document has moved &amp;lt;a href=&quot;http://www.expertsrt.com/&quot;&amp;gt;here&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哎呀! 看起来好像我们请求的文件已经不在那儿了; 它已经被移到新的地方了: &lt;code&gt;http://www.expertsrt.com&lt;/code&gt;. 如果你使用浏览器, 你只会看到 HTML - 在第一个空白行之前的都是头信息. 实际上, 现代浏览器比这更智能 - 当他们看到第三行的新的 URL 时, 会自动转向那里, 这样你就不用手动再输入这个新的 URL 了. 让我们去这个新的 URL. 这时可能你已经断开连接了. 如果这样, 只需按向上键, telnet 命令会出现, 然后回车以重新连接. 如果你没有断开连接, 那直接输入下面的文字就行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1
Host: www.expertsrt.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后回车两次. 你会看到另一个类似的响应, 告诉你那个页面实际上在 &lt;code&gt;http://www.expertsrt.com/index.php&lt;/code&gt;. 服务器真挑剔是不是? ;-) 重复上面的操作, 不过这次输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /index.php HTTP/1.1
Host: www.expertsrt.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意我们想要的文件名在第一行. 这一次我们屏幕被文字刷满了: 这就是来自 ERT 主页的 HTML. 这里的头信息看起来是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Wed, 08 Feb 2006 08:20:07 GMT
Server: Apache/2.0.54 (Debian GNU/Linux) mod_auth_pgsql/2.0.2b1 mod_ssl/2.0.54 OpenSSL/0.9.7e
X-Powered-By: PHP/4.4.0
Transfer-Encoding: chunked
Content-Type: text/html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单是不是? 我们来继续探讨这跟你编程有什么关系. 如果你不明白我们讲到的所有事情也没有关系. 重要的是对浏览器和服务器如何交互的有个大致印象, 以及意识到并没有什么魔法在里面. 最终就是这些&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浏览器和服务器通过使用头信息来进行交互&lt;/li&gt;
  &lt;li&gt;头信息在主要内容之前发送, 并且用两个 &lt;a href=&quot;http://www.google.com/search?q=define%3ACRLF&quot;&gt;CRLF&lt;/a&gt;/换行符 来和主要内容分割开&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在头信息部分, 每一行就是一个头. 首先是头的名字, 然后是一个冒号一个空格, 然后是这个头的名/值&lt;/p&gt;

    &lt;p&gt;头名: 头值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;头信息可以包括许多类型的信息和指示, 以便浏览器和服务器用来告知对方接下来该做什么&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 如果你是那种刨根问底的人, 你可以看看 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616.html&quot;&gt;RFC 2616&lt;/a&gt;, 那是 HTTP/1.1 的完整规范. 尤其是 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14&quot;&gt;14 章&lt;/a&gt;, 包含每一个头的完整定义&lt;/p&gt;

&lt;p&gt;#PHP header(): 基础&lt;/p&gt;

&lt;p&gt;注意在我们最终得到的主页中的 X-Powered-By: PHP/4.4.0 和 Content-Type: text/html 这两个头信息. PHP 一开始就被设计成输出 HTML ( PHP 中的 H 即代表 ‘Hypertext’), 并且在 PHP 脚本第一次生成输出(比如, 使用 echo)时, 会自动为你包含这些头信息. 这非常方便, 但也造成许多 PHP 新手对头信息的困惑 - 在像 Perl 这样不是一开始就被设计成用于 web 开发的语言中, 不包含你自己的头而直接发送输出会产生 ‘500 Internal Server Error’ 错误, 所以 Perl 的 web 开发者不得不立即学习关于头信息的知识&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.php.net/manual/function.header.php&quot;&gt;&lt;code&gt;header()&lt;/code&gt;&lt;/a&gt; 函数发送 HTTP 响应头信息, 而且只做这件事&lt;/p&gt;

&lt;p&gt;使用这个函数, 你可以让你的脚本发送你选择的头信息给浏览器, 创造一个非常有用的动态结果. 但是, 你需要知道关于 &lt;code&gt;header()&lt;/code&gt; 函数的第一件事就是你必须在 PHP 发送任何输出(这会使 PHP 自动发送默认的头信息)&lt;strong&gt;之前&lt;/strong&gt;使用它&lt;/p&gt;

&lt;p&gt;我怀疑有哪个 PHP 程序员没有见到过如下的错误消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Warning: Cannot modify header information - headers already sent by.....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如我们所说的, 响应头信息用一个空白行和主要内容分割. 这意味你仅可以发送头信息一次, 如果你的脚本有任何输出 (即使一个在 &lt;code&gt;&amp;lt;?php&lt;/code&gt; 标签之前的空白行或空格), PHP 就会自动发送头信息. 例如, 看一下下面这个脚本, 看起来逻辑上很正常:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;Welcome to my website!&amp;lt;br /&amp;gt;
&amp;lt;?php
  if($test){
   echo &quot;You&#39;re in!&quot;;
  }
  else{
    header(&#39;Location: http://www.mysite.com/someotherpage.php&#39;);
  }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个脚本判断 &lt;code&gt;$test&lt;/code&gt; 是否为 true, 如果不是则使用 &lt;code&gt;Location&lt;/code&gt; 头重定向访问者. 看到问题所在了吗? ‘Welcome…’ 文字始终会发送出去, 所以默认的头信息会自动被发送. 在调用 &lt;code&gt;header()&lt;/code&gt; 时已经太晚了: 用户只看到一条错误消息 (如果你把错误报告关掉了, 则只会看到 ‘Welcome…’ 文字), 而不是被重定向&lt;/p&gt;

&lt;p&gt;基本上有两种解决方法. 第一个就是重写代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
  if($test){
   echo &#39;Welcome to my website&amp;lt;br /&amp;gt;You&#39;re in!&#39;;
  }
  else{
    header(&#39;Location: http://www.mysite.com/someotherpage.php&#39;);
  }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个就是使用&lt;a href=&quot;http://www.php.net/outcontrol&quot;&gt;输出缓冲&lt;/a&gt;, 这个解决方法更为优雅易用. 在我们上面的例子中, 重写代码并不困难, 但是试想一下如果有很多 HTML 需要移动位置 - 这样做就会很麻烦, 也会让我们的代码更难追踪. 虽然我们第一个示例导致了错误, 但是逻辑上是没错的. 输出缓冲可以让你一直保留(‘缓冲’)输出(即使是 PHP 代码之外的 HTML)直到你明确指示了把输出发送给浏览器. 这样你就可以随意编写你的代码, 知道你指定了你需要指定的头信息, 然后明确指示发送这些输出. 两个相关的函数是 &lt;a href=&quot;http://www.php.net/manual/function.ob-start.php&quot;&gt;&lt;code&gt;ob_start()&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;http://www.php.net/manual/function.ob-flush.php&quot;&gt;&lt;code&gt;ob_flush()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;ob_start() &lt;/code&gt;用于打开输出缓冲, &lt;code&gt;ob_flush()&lt;/code&gt; 会发送缓冲了的输出:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
 ob_start();  //开始输出缓冲
?&amp;gt;
Welcome to my website!
&amp;lt;?php
  if(true){
   echo &quot;You&#39;re in!&quot;;
  }
  else{
    header(&#39;Location: http://www.mysite.com/someotherpage.php&#39;);
  }

  ob_flush(); //输出缓冲中的数据
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我鼓励你读一下所有关于输出缓冲的函数, 非常有用. 你应当尽早的把输出缓冲发送出去, 尤其当你有许多东西想要发送的时候. 否则你的页面会看起来加载的很慢, 因为所有的内容只有被组装完毕后才发送, 而不是当可用的时候立即就被发送出去.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示: 第二个参数&lt;/strong&gt; 如果你调用 header() 不止一次发送同一个头, 这个头的值将会是_最后_调用的 header() 中设置的值. 如,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
header(&#39;Some-Header: Value-1&#39;);
header(&#39;Some-Header: Value-2&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会产生 &lt;code&gt;Some-Header: Value-2&lt;/code&gt; 这个结果. 你可以通过设置第二个参数来发送同一个头两次. 这个参数默认是 true. 如果你设置其为 false, 那么第二个头值不会替换第一个, 而是两个都被发送. 所以下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
header(&#39;Some-Header: Value-1&#39;);
header(&#39;Some-Header: Value-2&#39;, false); //不要替换第一个
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将会产生 &lt;code&gt;Some-Header: Value-1, Value-2&lt;/code&gt; 这个结果. 你很少会用到这个, 但是知道它也不错.&lt;/p&gt;

&lt;p&gt;知道了 HTTP header 和 PHP 如何配合之后, 让我们来看一些更为具体的例子.&lt;/p&gt;

&lt;p&gt;#PHP header(): 一些例子&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 下面这个代码片断都是截取自完整的工作代码. 当你在自己的程序中包含他们的时候, 记得定义所有你自己的变量, 赋给他们默认值, 以及遵循其他最佳实践.&lt;/p&gt;

&lt;p&gt;##使用 &lt;code&gt;Location&lt;/code&gt; 头重定向&lt;/p&gt;

&lt;p&gt;我们已经在上面看到过几次了: 它会重定向浏览器.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
header(&#39;Location: http/www.mysite.com/new_location.html&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然你给它一个相对 URL 没准也能工作, 但是根据 HTTP 规范, 你真的应该使用一个绝对 URL.&lt;/p&gt;

&lt;p&gt;一个容易犯的错误就是在使用了 Location header 之后不立即使用 &lt;a href=&quot;http://www.php.net/manual/function.exit.php&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; 以结束执行 (你可能不是总是想要结束执行, 但是大部分时间是的). 之所以这是一个错误是因为 PHP 代码会继续执行, 即使用户已经被重定向到新的 URL. 在最好的情况下, 这会不必要的使用系统资源. 在最坏的情况下, 你可能会执行一些让自己后悔的操作. 看一下下面的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
//重定向访问级别低于 4 的用户
if (check_access_level($username) &amp;lt; 4){
  header(&#39;Location: http://www.mysite.com/someotherpage.php&#39;);
}

//向高于访问级别 4 的用户发送秘密邮件
mail_secret_code($username);
echo &#39;The secret email is on its way!&#39;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未授权用户的确被重定向了, 但是因为代码会继续执行, 他们同样会收到邮件. 为了避免这种情况, 针对已授权用户的代码可以写到 &lt;code&gt;else{}&lt;/code&gt; 声明中, 但是直接在 &lt;code&gt;header()&lt;/code&gt; 后面使用 &lt;code&gt;exit&lt;/code&gt; 来结束代码执行会更为干净容易一些.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
//重定向访问级别低于 4 的用户
if (check_access_level($username) &amp;lt; 4){
  header(&#39;Location: http://www.mysite.com/someotherpage.php&#39;);
  exit; //停止代码执行
}

//向高于访问级别 4 的用户发送秘密邮件
mail_secret_code($username);
echo &#39;The secret email is on its way!&#39;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##使用 &lt;code&gt;Refresh&lt;/code&gt; 头重定向&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Refresh&lt;/code&gt; 和 &lt;code&gt;Location&lt;/code&gt; 一样可以重定向用户, 但是你可以延迟重定向. 例如, 下面的代码会在显示当前页面 10 秒钟后重定向用户到新的页面:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
header(&#39;Refresh: 10; url=http://www.mysite.com/otherpage.php&#39;);
echo &#39;You will be redirected in 10 seconds&#39;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个常见的用途就是通过重复的’重定向’一个页面到它自身来强制更新页面 (参见&lt;a href=&quot;#secondConv&quot;&gt;上面&lt;/a&gt;的第二个 ‘对话’). 例如, 这里是一个简单的例子, 页面会从 10 开始向下数, 每个数字之间有 3 秒间隔:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
if(!isset($_GET[&#39;n&#39;])){
    $_GET[&#39;n&#39;] = 10;
}

if($_GET[&#39;n&#39;] &amp;gt; 0){
  header(&#39;Refresh: 3; url=&#39; . $_SERVER[&#39;PHP_SELF&#39;].&#39;?n=&#39; . ($_GET[&#39;n&#39;]-1)  );
  echo $_GET[&#39;n&#39;];
}
else{
  echo &#39;BLAST OFF!&#39;;
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 如果刷新时间设置成 0, 则 &lt;code&gt;Refresh&lt;/code&gt; 头实际上和 &lt;code&gt;Location&lt;/code&gt; 头完全一样&lt;/p&gt;

&lt;p&gt;##使用 &lt;code&gt;Content-Type&lt;/code&gt; 头来提供不同类型的文件以及生成动态内容&lt;/p&gt;

&lt;p&gt;服务器用 &lt;code&gt;Content-Type&lt;/code&gt; 头告诉浏览器自己将要发送什么类型的数据. 使用这个头信息, 你可以让 PHP 脚本输出任何类型的文件, 从纯文本文件到图片文件到 zip 文件等等. 下面的表格列举了最常用的一个 &lt;a href=&quot;http://en.wikipedia.org/wiki/Mime_type&quot;&gt;MIME 类型&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用 MIME 类型:&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;text/html&lt;/td&gt;
      &lt;td&gt;HTML (PHP 默认)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;text/plain&lt;/td&gt;
      &lt;td&gt;纯文本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;image/gif&lt;/td&gt;
      &lt;td&gt;GIF 图片&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;image/jpeg&lt;/td&gt;
      &lt;td&gt;JPEG 图片&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;image/png&lt;/td&gt;
      &lt;td&gt;PNG 图片&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;video/mpeg&lt;/td&gt;
      &lt;td&gt;MPEG 视频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;audio/wav&lt;/td&gt;
      &lt;td&gt;WAV 音频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;audio/mpeg&lt;/td&gt;
      &lt;td&gt;MP3 音频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;video/mov&lt;/td&gt;
      &lt;td&gt;mov 视频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;video/quicktime&lt;/td&gt;
      &lt;td&gt;Quicktime 视频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;video/x-ms-wmv&lt;/td&gt;
      &lt;td&gt;Windows WMV 视频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;audio/x-ms-wma&lt;/td&gt;
      &lt;td&gt;Windows WMA 音频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;audio/x-realaudio&lt;/td&gt;
      &lt;td&gt;RealPlayer 音频/视频 (.rm)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;audio/x-pn-realaudio&lt;/td&gt;
      &lt;td&gt;RealPlayer 音频/视频 (.ram)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;video/x-msvideo&lt;/td&gt;
      &lt;td&gt;ms 视频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;video/avi&lt;/td&gt;
      &lt;td&gt;AVI 视频&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;application/pdf&lt;/td&gt;
      &lt;td&gt;PDF 文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;application/msword&lt;/td&gt;
      &lt;td&gt;MS Word .doc 文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;application/zip&lt;/td&gt;
      &lt;td&gt;Zip 文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;application/octet-stream&lt;/td&gt;
      &lt;td&gt;其他. 数据. 用于强制下载或使用应用打开.*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x-foo/x-bar&lt;/td&gt;
      &lt;td&gt;其他. 数据. 用于强制下载或使用应用打开.*&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;你可以用此来做一些有趣的事情. 比如, 你可能想要向用户发用一个预先格式化过的文本文件, 而不是 HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
header(&#39;Content-Type: text/plain&#39;);
echo $plain_text_content;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另或者你想要提示用户下载文件, 而不是在浏览器中查看它. 使用 &lt;code&gt;Content-Disposition&lt;/code&gt; 头, 这很容易, 你甚至可以推荐一个文件名给用户:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
header(&#39;Content-Type: application/octet-stream&#39;);
header(&#39;Content-Disposition: attachment; &#39;
       .&#39;filename=&quot;plain_text_file.txt&quot;&#39;);
echo $plain_text_content;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另或者你需要提供文件文件, 但是又希望隐藏文件的真实路径和名字, 并且只让已登录的用户下载:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
if($b_is_logged_in){
   header(&#39;Content-Type: application/octet-stream&#39;);
   header(&#39;Content-Disposition: attachment; &#39;
           .&#39;filename=&quot;&#39;.$different_filename.&#39;&quot;&#39;);
   readfile(&#39;/path/to/files/&#39; . $filename);
}
else{
   echo &#39;You are not authorized to view this file&#39;;
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又或者你已经使用 PHP 的&lt;a href=&quot;http://www.php.net/manual/ref.image.php&quot;&gt;图片函数&lt;/a&gt;动态生成了一个图片, 想要展示给用户. 你可以创建一个 &lt;code&gt;build_image.php&lt;/code&gt; 文件, 像这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
   //生成图片, 然后
   header(&#39;Content-Type: image/jpeg&#39;);
   imagejpeg($image_resouce);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 当心 &lt;a href=&quot;http://www.php.net/magic_quotes&quot;&gt;&lt;code&gt;magic_quotes&lt;/code&gt;&lt;/a&gt;! PHP 会自动使用反斜杠转移特殊字符, 这一开始看起来是个好主意, 但是大多数好的程序员认为 (a) 这会鼓励不去验证输入的粗心代码, 并且 (b) 在良好的代码中会产生本不该有 (如果 &lt;code&gt;magic_quote&lt;/code&gt; 关闭) 的麻烦. 其中一个麻烦就是二进制数据被破坏. 在上面这个例子中, 如果 &lt;a href=&quot;http://www.php.net/manual/en/ref.info.php#ini.magic-quotes-runtime&quot;&gt;&lt;code&gt;magic_quotes_runtime&lt;/code&gt;&lt;/a&gt;被启用, 则 &lt;code&gt;readfile()&lt;/code&gt; 输出的数据可能被添加反斜杠, 导致发送给用户的文件被破坏. 完美情况下, 你应该在 &lt;code&gt;php.ini&lt;/code&gt; 文件中关闭 &lt;code&gt;magic_quotes_runtime&lt;/code&gt; 选项, 但是如果你没有权限访问这个配置文件, 你可以使用 &lt;a href=&quot;http://www.php.net/manual/en/function.set-magic-quotes-runtime.php&quot;&gt;&lt;code&gt;set_magic_quotes_runtime()&lt;/code&gt;&lt;/a&gt; 函数 (给它传个数字 0) 关闭它.&lt;/p&gt;

&lt;p&gt;令人高兴的是, 最近的一次 PHP &lt;a href=&quot;http://www.php.net/~derick/meeting-notes.html#magic-quotes&quot;&gt;开发者会议&lt;/a&gt;显示, 在未来版本(6+) 的 PHP 中 &lt;code&gt;magic quotes&lt;/code&gt; 会被弃用. 但是在所有人升级到这个版本的 PHP 之前, 记住这个导致的问题会节省你很多麻烦和疑问.&lt;/p&gt;

&lt;p&gt;你可以在 URL 中传递生成图片所需的参数, 然后使用 $_GET 获取它们. 然后在另一个页面, 你可以使用 img 标签来包含这个图片:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;img src=&quot;build_image.php&amp;lt;?php echo &quot;?$user_id&amp;amp;amp;$caption&quot;; ?&amp;gt;&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可用的地方几乎讲不完. 你 PHP 变成越多, 越会发现 &lt;code&gt;Content-Type&lt;/code&gt; 头真的是你的好朋友&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 浏览器处理各式 &lt;code&gt;MIME类型&lt;/code&gt; 的_预期_方式以及_实际_方式可能并不一致 (尤其是 Internet Explorer), 所以你最好是在你需要支持的浏览器中测试一下. PHP 参考中的&lt;a href=&quot;http://www.php.net/manual/function.header.php#usernotes&quot;&gt;用户评论&lt;/a&gt;有许多关于此的技巧.&lt;/p&gt;

&lt;p&gt;##防止页面缓存&lt;/p&gt;

&lt;p&gt;PHP 页面通常会生成非常动态的内容, 为了防止用户因为页面缓存而错过了更新过的页面, 告诉浏览器不要缓存特定的页面通常非常有用. 下面的代码在可能会访问你网站的浏览器中工作的很好:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
header(&#39;Cache-Control: no-cache, no-store, must-revalidate&#39;); //HTTP/1.1
header(&#39;Expires: Sun, 01 Jul 2005 00:00:00 GMT&#39;);
header(&#39;Pragma: no-cache&#39;); //HTTP/1.0
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Expires&lt;/code&gt; 头可以是任何已经过去的日期. 对于 &lt;code&gt;MIME 类型&lt;/code&gt;, 浏览器 (尤其是较老的) 可能不会总是正确的理解你的缓存指示 (虽然大部分现代浏览器会).&lt;/p&gt;

&lt;p&gt;##其他应用&lt;/p&gt;

&lt;p&gt;还有另外一个可以使用头信息的地方, 比如设置 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;HTTP 响应码&lt;/a&gt;, 或者执行 &lt;a href=&quot;http://www.php.net/manual/features.http-auth.php&quot;&gt;HTTP 认证&lt;/a&gt; (如果你作为 &lt;code&gt;Apache&lt;/code&gt; 模块来使用 PHP 的话). 现在, 你了解了 header() 如何工作及怎么使用它, 你可以用它做你之前想都没想到的许多事情了.&lt;/p&gt;

&lt;p&gt;#PHP 中的请求头信息&lt;/p&gt;

&lt;p&gt;我们讲了怎么使用响应头信息了. 我们还可以从浏览器发给服务器的请求头信息中获取很多信息. 有两种方法来获取. 第一, 许多 [&lt;code&gt;$_SERVER&lt;/code&gt;数组][server]中的值都是由传来的请求头信息决定的. 第二, 如果 PHP 是作为 &lt;code&gt;Apache&lt;/code&gt; 模块使用的, &lt;a href=&quot;http://www.php.net/manual/function.apache-request-headers.php&quot;&gt;&lt;code&gt;apache_request_headers()&lt;/code&gt;&lt;/a&gt; 会返回一个包含所有请求头信息的数组 (甚至那些不在 &lt;code&gt;$_SERVER&lt;/code&gt; 中的).&lt;/p&gt;

&lt;p&gt;##安全第一: 不要信任请求头信息&lt;/p&gt;

&lt;p&gt;因为请求头信息发自浏览器, 浏览器又可以在客户端被控制, 所以你&lt;strong&gt;永远不要信任来自请求头, 又和你站点安全紧密相关的头信息&lt;/strong&gt;. 一个很好的例子就是 &lt;code&gt;$_SERVER[&#39;HTTP_REFERER&#39;]&lt;/code&gt;变量, 这个变量应该包含一个用户转自的源 URL. 一个新手的常见错误就是认为他们可以使用这个来确保用户只会通过特定路径来访问页面, 因此他们便无需关心服务器端的数据验证. 例如, 看看下面的代码, 它试着去确保数据是从一个特定的页面发送过来的, 而不是从另一个站点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
 if($_SERVER[&#39;HTTP_REFERER&#39;] != &#39;http://www.mysite.com/myform.html&#39;){
   header(&#39;Refresh: 5; url=http://www.mysite.com/myform.html&#39;);
   echo &#39;You must use the form on my site...redirecting now.&#39;;
 }
 else{
   insert_data($_POST[&#39;var1&#39;], $_POST[&#39;var2&#39;]);
 }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这或许会阻止那些不是很精通的黑客通过他的浏览器提交一个自定义的表单来提交数据, 但是任何一个稍微高深一些的黑客都可以通过使用 &lt;code&gt;telnet&lt;/code&gt; 来提交数据, 包括请求头信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Referer: http://www.mysite.com/myform.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后轻易的躲过这层保护机制. 这里所要讲的重点是: 使用 HTTP 请求头信息来统计一些数据以便提供更好的用户体验 - 大部分的请求头信息都是发自真实的浏览器而且可以被信任…但是&lt;strong&gt;不要&lt;/strong&gt;在有关安全的问题上依赖任何请求 header&lt;/p&gt;

&lt;p&gt;##使用 HTTP 请求头信息&lt;/p&gt;

&lt;p&gt;你可以用它做几件事. 使用 &lt;code&gt;$_SERVER[&#39;HTTP_USER_AGENT&#39;]&lt;/code&gt;你可以探测用户生成他使用的什么浏览器. 你可以检查 &lt;code&gt;$_SERVER[&#39;HTTP_ACCEPT_LANGUAGE&#39;]&lt;/code&gt; (可能要配合 &lt;code&gt;$_SERVER[&#39;HTTP_ACCEPT_CHARSET&#39;]&lt;/code&gt; 和一些 &lt;a href=&quot;http://www.expertsrt.com/articles/Rod/city_country_IP.php&quot;&gt;IP 地理位置&lt;/a&gt; ) 来决定向用户展示什么语言. 虽然 &lt;code&gt;$_SERVER[&#39;HTTP_REFERER&#39;]&lt;/code&gt; 对于安全目的并不能被依赖, 但是可以用来统计你网站的流量, 或者根据用户的访问路径来定制显示内容. 如果因为某些原因你想要操作原始的请求字符串, 你可以使用 &lt;code&gt;$_SERVER[&#39;QUERY_STRING&#39;]&lt;/code&gt;. 查看 &lt;code&gt;$_SERVER[&#39;REQUEST_METHOD&#39;]&lt;/code&gt; 可以知道你的页面是通过 &lt;code&gt;GET&lt;/code&gt; 还是 &lt;code&gt;POST&lt;/code&gt; 方法访问的. 还有很多可以帮助你做许多有创意的事情的信息等着你去发现.&lt;/p&gt;

&lt;p&gt;#HTML &lt;code&gt;meta&lt;/code&gt; 标签中的 HTTP 头信息 equivalents(对应物)&lt;/p&gt;

&lt;p&gt;很有可能在阅读本文之前, 你已经用过下面的 HTML meta 标签重定向用户了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;http://www.mysite.com/somepage.html&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来很熟悉? ‘http-equiv’ &lt;code&gt;meta&lt;/code&gt; 标签即 HTTP 响应头的’对应物’, 引入它们是为了让没有服务器端编程能力的人在写 HTML 页面的时候也能使用强大的头信息功能. 使用这些 meta 标签很简单: 它们可以被放在文档 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中的任何地方, &lt;code&gt;http-equiv&lt;/code&gt; 属性包含头名, &lt;code&gt;content&lt;/code&gt; 属性包含头值.&lt;/p&gt;

&lt;p&gt;我发现这些 meta 标签最开始也会和 HTTP 头一样让人困惑, 但是现在它们在你看来应该很简单了. 虽然我更喜欢使用 PHP 的 &lt;code&gt;header()&lt;/code&gt; 函数, 但是 &lt;code&gt;meta&lt;/code&gt; 标签的 HTTP equivalents 对于像指定字符集这样的事情会更顺手一些. 比如, 我经常在 HTML 页面中使用 (有时候 PHP 页面中也会用到):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 使用 &lt;code&gt;meta&lt;/code&gt; 标签来指定头信息并不被一致的支持, 所以通常来讲使用头信息本身会更加安全和快速. 另外很明显, 还有一些头的名值对并不能用 &lt;code&gt;meta equivalents&lt;/code&gt; 来指定: 在真正的头信息被发送, 浏览器已经把文档读取为 HTML 之后, 你是不能再去设置 &lt;code&gt;Content-Type&lt;/code&gt; 成 &lt;code&gt;image/png&lt;/code&gt; 的 ;-)&lt;/p&gt;

&lt;p&gt;#结语&lt;/p&gt;

&lt;p&gt;现在我们讲完了, 你应该对 HTTP 的工作原理以及如何使用响应请求头信息以及如何把它们应用到自己的代码中有了很好的认识. 这些知识也会让你在 web 应用的效率和安全方面有更审慎的思考. 我希望在你继续编程的时候, 会发现你使用 HTTP 头信息更加顺手了, 也能通过使用它们让你的工作更加轻松, 你的页面更好了.&lt;/p&gt;

&lt;p&gt;还有额外一点, 记住头信息就像是词语: 它们交流信息并请求某些操作被执行, 但是本身并不强制任何事情. 99.9% 的情况下, 浏览器和服务器和谐合作, 事情发展很顺利. 但记住在现实中, 是不是你会遇到一些混蛋 (黑客), 或者一些只想按照自己意愿做事的东西 (Internet Explorer). web 开发从很多角度讲是一个客服性质的工作, 所以你应该尽全力避免这些东西, 满足客户的 ‘特殊需要’ :-)&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 26 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://panke.me//translation/Http_headers_and_PHP_header()_function</link>
        <guid isPermaLink="true">http://panke.me//translation/Http_headers_and_PHP_header()_function</guid>
        
        <category>php</category>
        
        <category>http</category>
        
        
        <category>translation</category>
        
      </item>
    
  </channel>
</rss>